// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © restructured_approach

//@version=6
indicator(title = "BOS_CHoCH_EC_FVG_RSI",
     overlay = true,
     max_labels_count = 500,
     max_lines_count = 500,
     max_boxes_count = 500)
// import TradingView/Strategy/3

// === USER INPUTS ===
show_debug_labels = input.bool(defval = false, title = "Show Debug Labels")
g_Market_Struct_Controls = "Controls Related To Market Structure Detection"
local_high_or_low_search_window_size = input.int(defval = 2, title = "Pivot Search Window", minval = 1, maxval = 10, group = g_Market_Struct_Controls)
pattern_search_loop_window_size = input.int(defval = 10, title = "Pattern Confirmation Window", minval = 5, maxval = 50, group = g_Market_Struct_Controls)
candle_data_storage_map_size = input.int(defval = 4000, title = "Data Storage Size", minval = 100, maxval = 5000, step = 100)

// RSI related inputs
g_RSI_Settings = "RSI Settings"
enableRSICheck = input.bool(defval = true, title = "Enable RSI Filter", 
     tooltip = "When enabled, signals require RSI divergence confirmation", group = g_RSI_Settings)
rsiLength = input.int(defval = 14, title = "RSI Length", minval = 2, maxval = 50, group = g_RSI_Settings)
rsiCalculationMethod = input.string(defval = "Simple", title = "RSI Calculation Method", 
     options = ["Simple", "Wilder's Smoothing"], 
     tooltip = "Simple: Standard SMA-based RSI\nWilder's: Uses exponential smoothing (more like ta.rsi)", 
     group = g_RSI_Settings)

// FVG related inputs
g_FVG_Filter = "Fair Value Gap (FVG) Filter"
fvgbarsRightLimit = input.string(title = "Mode Selection for FVG Bars right edge", defval = "Current w Offset", options = ["Infinite", "Current w Offset"], group=g_FVG_Filter)
fvgbarsLeftOffset = input.int(defval = 0, minval=0, title="FVG Plots Left Offset", group=g_FVG_Filter)
fvgbarsRightOffset= input.int(title = "Offset for FVG Bars right edge index", defval = 4, minval=0, group=g_FVG_Filter)
fvgbarsRightLimitValue = switch fvgbarsRightLimit
    "Infinite" => na
    "Current w Offset" => bar_index + fvgbarsRightOffset
    => na  // default
// Add to existing FVG Filter group
retestProximityThresholdPips = input.int(title="Retest Proximity Threshold (Pips)", defval=5, minval=0, 
     tooltip="How close the candle needs to be to the BOS retest zone to trigger signal", group=g_FVG_Filter)
// enableFVGBarDeletion = input.bool(defval=true, title="To toggle FVG Bar Deletion (TESTING)", group=g_FVG_Filter)
priceSourceStr = input.string("Close", "Price Source", options = ["Close", "High", "Low", "Open"], group=g_FVG_Filter)
localTrendPriceSource = switch priceSourceStr
    "Close" => close
    "High" => high
    "Low" => low
    "Open" => open
    => close  // default

// === DEBUG TABLE SETUP ===
// Table for displaying real-time trend analysis scores
var table debugTable = table.new(position.top_right, 2, 30, 
     bgcolor = color.new(color.white, 80), 
     border_width = 1, 
     border_color = color.gray,
     frame_width = 1,
     frame_color = color.gray)

// === PIP CONVERSION FUNCTIONS ===
// Get pip size for current instrument
getPipSize() =>
    float pip_size = na
    
    // Determine asset type and set pip size accordingly
    if syminfo.type == "forex"
        // Forex pairs
        if str.contains(syminfo.currency, "JPY") or str.contains(syminfo.basecurrency, "JPY")
            // JPY pairs: 1 pip = 0.01
            pip_size := 0.01
        else
            // Most other forex pairs: 1 pip = 0.0001
            pip_size := 0.0001
   
    else if syminfo.type == "crypto"
        // Crypto: Use adaptive approach based on price level and mintick
        current_price = close
        if current_price >= 10000
            // High-value crypto (like BTC): 1 pip = 1.0
            pip_size := 1.0
        else if current_price >= 1000
            // Medium-value crypto: 1 pip = 0.1
            pip_size := 0.1
        else if current_price >= 100
            // Lower-value crypto: 1 pip = 0.01
            pip_size := 0.01
        else if current_price >= 1
            // Very low-value crypto: 1 pip = 0.001
            pip_size := 0.001
        else
            // Micro-value crypto: Use 10x mintick as pip
            pip_size := syminfo.mintick * 10
    
    else if syminfo.type == "index" or syminfo.type == "cfd"
        // Indices and CFDs: Use mintick-based approach
        if syminfo.mintick >= 1.0
            // Large tick indices (like Nikkei): 1 pip = mintick
            pip_size := syminfo.mintick
        else if syminfo.mintick >= 0.1
            // Medium tick indices: 1 pip = mintick * 10
            pip_size := syminfo.mintick * 10
        else
            // Small tick indices: 1 pip = mintick * 100
            pip_size := syminfo.mintick * 100
    
    else if syminfo.type == "stock"
        // Stocks: Usually 1 pip = 0.01 (1 cent)
        pip_size := math.max(0.01, syminfo.mintick)
    
    else
        // Commodities and others: Adaptive approach
        if syminfo.mintick >= 1.0
            // Large tick commodities (like crude oil): 1 pip = mintick
            pip_size := syminfo.mintick
        else if syminfo.mintick >= 0.1
            // Medium tick: 1 pip = mintick * 10
            pip_size := syminfo.mintick * 10
        else if syminfo.mintick >= 0.01
            // Small tick: 1 pip = mintick * 100
            pip_size := syminfo.mintick * 100
        else
            // Very small tick: 1 pip = mintick * 1000
            pip_size := syminfo.mintick * 1000
    
    pip_size

// Convert pips to price points
pipsToPrice(pips) =>
    pip_size = getPipSize()
    pips * pip_size

// Convert price points to pips
priceToPips(price_diff) =>
    pip_size = getPipSize()
    price_diff / pip_size

// Get detailed instrument information
getInstrumentInfo() =>
    pip_size = getPipSize()
    [syminfo.type, syminfo.basecurrency, syminfo.currency, syminfo.mintick, pip_size, syminfo.pointvalue]
// call this utility information for the table
[instrument_type, instrument_basecurrency, instrument_currency, instrument_mintick, pip_size, instrument_pointvalue] = getInstrumentInfo()

// === GLOBAL VARS ===
var bool phase_one_complete = false
var bool phase_two_complete = false
var int last_historical_bar_index = na

// === UDTs ===
type BarData
    int   barIndex
    float bar_open
    float bar_high
    float bar_low
    float bar_close
    float bar_volume
    float bar_rsi

type StructureLevel
    int    barIndex
    float  price_level
    bool   is_confirmed
    bool   is_pivot_internal_to_bos // identify if the pivot was formed in a BOS (hence internal) or outside using a 2 candle rule.
    bool   is_pivot_internal_to_choch // identify if the pivot lies within a choch zone, i.e., pivot high in a Bearish and pivot low in a bullish choch.
    string level_type  // "pivot_high", "pivot_low"
    label  structure_label
    int    confirmation_bar
    int    crossing_struct_event_bar // Bar index where this pivot point was crossed to make a BOS or CHOCH
    bool   is_resolved  // Has this pivot been broken by BOS/CHoCH

type StructureEvent
    int    trigger_bar_index // zone end
    float  broken_level
    string event_type  // "BOS" or "CHoCH"
    string direction   // "bullish" or "bearish"
    int    reference_pivot_bar // zone start
    int    internal_pivot_bar // index of pivot found internal to structure event
    line   event_line
    label  event_label

type FVGBox
    int createdAtBar       // Custom property: bar index when created
    box boxRef             // Reference to the actual box object
    color bgColor          // Store background color separately
    int fvgType            // Custom property: 1 for bullish, -1 for bearish
    bool isEdited          // Track if this was deleted (for deleted array)
    bool isDeleted         // Track if this was deleted (for deleted array)
    int deletedAtBar       // Track when this was edited/deleted

// === GLOBAL STORAGE ===
var barMap = map.new<int, BarData>()
var array<StructureLevel> pivot_highs = array.new<StructureLevel>()
var array<StructureLevel> pivot_lows = array.new<StructureLevel>()
var array<StructureEvent> bos_events = array.new<StructureEvent>()
var array<StructureEvent> choch_events = array.new<StructureEvent>()
var array<FVGBox> fvgBoxArray = array.new<FVGBox>()

// === RSI CALCULATION FUNCTIONS ===
// Calculate RSI manually using barMap data
calculateRSI(int target_bar_index, int period) =>
    float rsi = na
    
    // Need at least 'period + 1' bars to calculate RSI
    if target_bar_index < period
        rsi
    else
        // Arrays to store gains and losses
        gains = array.new<float>()
        losses = array.new<float>()
        
        // Calculate price changes over the lookback period
        for i = 1 to period
            current_index = target_bar_index - (i - 1)
            previous_index = current_index - 1
            
            if map.contains(barMap, current_index) and map.contains(barMap, previous_index)
                current_bar = map.get(barMap, current_index)
                previous_bar = map.get(barMap, previous_index)
                
                price_change = current_bar.bar_close - previous_bar.bar_close
                
                if price_change > 0
                    array.push(gains, price_change)
                    array.push(losses, 0.0)
                else
                    array.push(gains, 0.0)
                    array.push(losses, math.abs(price_change))
            else
                // Missing data, can't calculate
                array.push(gains, 0.0)
                array.push(losses, 0.0)
        
        // Calculate average gain and average loss
        if array.size(gains) == period and array.size(losses) == period
            avg_gain = array.avg(gains)
            avg_loss = array.avg(losses)
            
            // Calculate RSI
            if avg_loss == 0
                rsi := 100.0  // No losses = RSI at maximum
            else
                rs = avg_gain / avg_loss
                rsi := 100 - (100 / (1 + rs))
        
        rsi

// === ADVANCED RSI WITH WILDER'S SMOOTHING ===
calculateRSIWilders(int target_bar_index, int period) =>
    float rsi = na
    
    if target_bar_index < period * 2  // Need more data for Wilder's smoothing
        rsi
    else
        // First, calculate initial average gain and loss using simple average
        gains = array.new<float>()
        losses = array.new<float>()
        
        for i = 1 to period
            current_index = target_bar_index - (i - 1)
            previous_index = current_index - 1
            
            if map.contains(barMap, current_index) and map.contains(barMap, previous_index)
                current_bar = map.get(barMap, current_index)
                previous_bar = map.get(barMap, previous_index)
                
                price_change = current_bar.bar_close - previous_bar.bar_close
                
                if price_change > 0
                    array.push(gains, price_change)
                    array.push(losses, 0.0)
                else
                    array.push(gains, 0.0)
                    array.push(losses, math.abs(price_change))
            else
                // Missing data, can't calculate
                array.push(gains, 0.0)
                array.push(losses, 0.0)
        
        if array.size(gains) == period and array.size(losses) == period
            // Initial averages
            avg_gain = array.avg(gains)
            avg_loss = array.avg(losses)
            
            // Apply Wilder's smoothing for the remaining bars
            for i = period + 1 to target_bar_index
                current_index = i
                previous_index = i - 1
                
                if map.contains(barMap, current_index) and map.contains(barMap, previous_index)
                    current_bar = map.get(barMap, current_index)
                    previous_bar = map.get(barMap, previous_index)
                    
                    price_change = current_bar.bar_close - previous_bar.bar_close
                    
                    current_gain = price_change > 0 ? price_change : 0
                    current_loss = price_change < 0 ? math.abs(price_change) : 0
                    
                    // Wilder's smoothing: (previous_avg * (n-1) + current_value) / n
                    avg_gain := (avg_gain * (period - 1) + current_gain) / period
                    avg_loss := (avg_loss * (period - 1) + current_loss) / period
            
            // Calculate RSI
            if avg_loss == 0
                rsi := 100.0  // No losses = RSI at maximum
            else
                rs = avg_gain / avg_loss
                rsi := 100 - (100 / (1 + rs))
        
        rsi

// Get RSI value for a specific bar (if already calculated)
getRSI(int target_bar_index) =>
    float rsi = na
    if map.contains(barMap, target_bar_index)
        bar_data = map.get(barMap, target_bar_index)
        rsi := bar_data.bar_rsi
    rsi

// === UTILITY FUNCTIONS - DATA STORAGE ===
createBarData(int barIndex, float Open, float High, float Low, float Close,
     float Volume, float Rsi, label pivot_high = na, label pivot_low = na) =>
    BarData.new(
         barIndex = barIndex,
         bar_open = Open,
         bar_high = High,
         bar_low = Low,
         bar_close = Close,
         bar_volume = Volume,
         bar_rsi = Rsi
         )

// Add bulk data for bars or update data for new bars after bulk data loading phase 
// Function to add/update a bar's data
addBarDataToMap(int barIndex, float Open, float High, float Low, float Close, float Volume) =>
    // ensure the bardata for this index is not already in the map
    if not map.contains(barMap, barIndex)
        // Calculate RSI using selected method
        float rsi_val = na
        if enableRSICheck  // Only calculate if RSI check is enabled
            // Make sure we have enough historical data
            if barIndex >= rsiLength + 1
                rsi_val := rsiCalculationMethod == "Wilder's Smoothing" ? 
                     calculateRSIWilders(barIndex, rsiLength) : 
                     calculateRSI(barIndex, rsiLength)
        
        // Create the new bar data object with RSI
        new_BarData_obj_ref = createBarData(barIndex, Open, High, Low, Close, Volume, rsi_val)
        // now enter it into the map 
        map.put(barMap, barIndex, new_BarData_obj_ref)
cleanupBarMapByRange() =>
    if not na(bar_index)
        cutoff_bar_index = bar_index - candle_data_storage_map_size
        map_keys = map.keys(barMap)
        for i = 0 to array.size(map_keys) - 1
            key = array.get(map_keys, i)
            if key < cutoff_bar_index
                map.remove(barMap, key)
            else
                // Since maps maintain insertion order, we can break early
                // once we find a key that's >= cutoff (all subsequent keys will be newer)
                break
    true // just because a return is needed

// === UTILITY FUNCTIONS - FVG DETECTION AND BOX CREATION ===
// Helper function to create a new FVGBox
createFVGBox(createdAtBar, left, int right = na, top, bottom, bgCol, fvgType) =>
    // Create the actual box
    boxRef = box.new(left=left, right=right, top=top, bottom=bottom, bgcolor=bgCol, border_color=color.new(color.white, 100))
    
    // Create and return the FVGBox instance
    FVGBox.new(createdAtBar, boxRef, bgCol, fvgType, false, false, na)

// Helper function to update box properties
updateFVGBox(fvgBox, color newBgColor=na, int newfvgType=na, bool newIsEdited=false, bool newIsDeleted=false, int newDeletedAtBar=na) =>
    if not na(newBgColor)
        fvgBox.bgColor := newBgColor
        box.set_bgcolor(fvgBox.boxRef, newBgColor)
    if not na(newfvgType)
        fvgBox.fvgType := newfvgType
    fvgBox.isEdited := newIsEdited
    fvgBox.isDeleted := newIsDeleted
    if not na(newDeletedAtBar)
        fvgBox.deletedAtBar := newDeletedAtBar

// Helper function to get properties from FVGBox
getFVGBoxTop(fvgBox) => box.get_top(fvgBox.boxRef)
getFVGBoxBottom(fvgBox) => box.get_bottom(fvgBox.boxRef)
getFVGBoxLeft(fvgBox) => box.get_left(fvgBox.boxRef)
getFVGBoxRight(fvgBox) => box.get_right(fvgBox.boxRef)

// Setter functions for FVGBox position properties
setFVGBoxTop(fvgBox, newTop) => box.set_top(fvgBox.boxRef, newTop)
setFVGBoxBottom(fvgBox, newBottom) => box.set_bottom(fvgBox.boxRef, newBottom)
setFVGBoxLeft(fvgBox, newLeft) => box.set_left(fvgBox.boxRef, newLeft)
setFVGBoxRight(fvgBox, newRight) => box.set_right(fvgBox.boxRef, newRight)

// Find index of an object in a custom array by createdAtBar:
findFvgBoxIndexByCreatedBar(arr, int targetBar) =>
    int idx = na
    if array.size(arr) > 0 and not na(targetBar)  // Added na check
        for i = 0 to array.size(arr) - 1
            boxItem = array.get(arr, i)
            if not na(boxItem) and boxItem.createdAtBar == targetBar  // Added na check
                idx := i
                break
    idx

// === UTILITY FUNCTIONS - BARINDEX-AWARE DATA RETRIEVAL FUNCTIONS ===
// PIVOT HIGH RELATED METHODS
getLastPivotHigh(int target_bar_index) =>
    StructureLevel result = na
    if array.size(pivot_highs) > 0
        i = array.size(pivot_highs) - 1
        while i >= 0
            pivot = array.get(pivot_highs, i)
            if pivot.barIndex <= target_bar_index
                result := pivot
                break
            i -= 1
    result

getLastUnresolvedPivotHigh(int target_bar_index) =>
    StructureLevel result = na
    if array.size(pivot_highs) > 0
        i = array.size(pivot_highs) - 1
        while i >= 0
            pivot = array.get(pivot_highs, i)
            if not pivot.is_resolved and pivot.barIndex <= target_bar_index
                result := pivot
                break
            i -= 1
    result

getLastResolvedPivotHigh(int target_bar_index) =>
    StructureLevel result = na
    if array.size(pivot_highs) > 0
        i = array.size(pivot_highs) - 1
        while i >= 0
            pivot = array.get(pivot_highs, i)
            if pivot.is_resolved and pivot.barIndex <= target_bar_index
                result := pivot
                break
            i -= 1
    result

// PIVOT LOW RELATED METHODS
getLastPivotLow(int target_bar_index) =>
    StructureLevel result = na
    if array.size(pivot_lows) > 0
        i = array.size(pivot_lows) - 1
        while i >= 0
            pivot = array.get(pivot_lows, i)
            if pivot.barIndex <= target_bar_index
                result := pivot
                break
            i -= 1
    result

getLastUnresolvedPivotLow(int target_bar_index) =>
    StructureLevel result = na
    if array.size(pivot_lows) > 0
        i = array.size(pivot_lows) - 1
        while i >= 0
            pivot = array.get(pivot_lows, i)
            if not pivot.is_resolved and pivot.barIndex <= target_bar_index
                result := pivot
                break
            i -= 1
    result

getLastResolvedPivotLow(int target_bar_index) =>
    StructureLevel result = na
    if array.size(pivot_lows) > 0
        i = array.size(pivot_lows) - 1
        while i >= 0
            pivot = array.get(pivot_lows, i)
            if pivot.is_resolved and pivot.barIndex <= target_bar_index
                result := pivot
                break
            i -= 1
    result

// BOS AND CHOCH RELATED METHODS
getLastBOS(int target_bar_index) =>
    StructureEvent result = na
    if array.size(bos_events) > 0
        i = array.size(bos_events) - 1
        while i >= 0
            event = array.get(bos_events, i)
            if event.trigger_bar_index <= target_bar_index
                result := event
                break
            i -= 1
    result

getLastCHOCH(int target_bar_index) =>
    StructureEvent result = na
    if array.size(choch_events) > 0
        i = array.size(choch_events) - 1
        while i >= 0
            event = array.get(choch_events, i)
            if event.trigger_bar_index <= target_bar_index
                result := event
                break
            i -= 1
    result

// Get the most recent market structure level (pivot high or low) before or at target_bar_index
getLastMarketLevelHighOrLow(int target_bar_index) =>
    StructureLevel last_pivot_high = na
    StructureLevel last_pivot_low = na
    
    // Get last pivot high before or at target_bar_index
    if array.size(pivot_highs) > 0
        i = array.size(pivot_highs) - 1
        while i >= 0
            pivot = array.get(pivot_highs, i)
            if pivot.barIndex <= target_bar_index
                last_pivot_high := pivot
                break
            i -= 1
    
    // Get last pivot low before or at target_bar_index
    if array.size(pivot_lows) > 0
        i = array.size(pivot_lows) - 1
        while i >= 0
            pivot = array.get(pivot_lows, i)
            if pivot.barIndex <= target_bar_index
                last_pivot_low := pivot
                break
            i -= 1
    
    // Return the most recent one
    if na(last_pivot_high) and na(last_pivot_low)
        na
    else if na(last_pivot_high)
        last_pivot_low
    else if na(last_pivot_low)
        last_pivot_high
    else
        last_pivot_high.barIndex > last_pivot_low.barIndex ? last_pivot_high : last_pivot_low

// Get the most recent market structure event (BOS or CHoCH) before or at target_bar_index
getLastMarketEventBOSorCHOCH(int target_bar_index) =>
    StructureEvent last_bos = na
    StructureEvent last_choch = na
    
    // Get last BOS before or at target_bar_index
    if array.size(bos_events) > 0
        i = array.size(bos_events) - 1
        while i >= 0
            event = array.get(bos_events, i)
            if event.trigger_bar_index <= target_bar_index
                last_bos := event
                break
            i -= 1
    
    // Get last CHoCH before or at target_bar_index
    if array.size(choch_events) > 0
        i = array.size(choch_events) - 1
        while i >= 0
            event = array.get(choch_events, i)
            if event.trigger_bar_index <= target_bar_index
                last_choch := event
                break
            i -= 1
    
    // Return the most recent event
    if na(last_bos) and na(last_choch)
        na
    else if na(last_bos)
        last_choch
    else if na(last_choch)
        last_bos
    else
        last_bos.trigger_bar_index > last_choch.trigger_bar_index ? last_bos : last_choch

// === DIAGNOSTIC FUNCTIONS ===
// Check if bar is already processed as a pivot
isBarAlreadyPivot(int barIndex) =>
    bool is_high_pivot = false
    bool is_low_pivot = false
    
    // Check pivot_highs array
    if array.size(pivot_highs) > 0
        for i = 0 to array.size(pivot_highs) - 1
            pivot = array.get(pivot_highs, i)
            if pivot.barIndex == barIndex
                is_high_pivot := true
                break
    
    // Check pivot_lows array
    if array.size(pivot_lows) > 0
        for i = 0 to array.size(pivot_lows) - 1
            pivot = array.get(pivot_lows, i)
            if pivot.barIndex == barIndex
                is_low_pivot := true
                break
    
    [is_high_pivot, is_low_pivot]

// === PIVOT DETECTION FUNCTIONS ===
// Check if current bar is a local high
isLocalHigh(int target_bar_index) =>
    if not map.contains(barMap, target_bar_index)
        false
    else
        target_bar = map.get(barMap, target_bar_index)
        bool is_highest = true
        
        // Check surrounding bars
        for offset = 1 to local_high_or_low_search_window_size
            // Check left side
            left_index = target_bar_index - offset
            if map.contains(barMap, left_index)
                left_bar = map.get(barMap, left_index)
                if left_bar.bar_high >= target_bar.bar_high
                    is_highest := false
                    break
            
            // Check right side
            right_index = target_bar_index + offset
            if map.contains(barMap, right_index)
                right_bar = map.get(barMap, right_index)
                if right_bar.bar_high >= target_bar.bar_high
                    is_highest := false
                    break
        
        // is_highest
        true

// Check if current bar is a local low
isLocalLow(int target_bar_index) =>
    if not map.contains(barMap, target_bar_index)
        false
    else
        target_bar = map.get(barMap, target_bar_index)
        bool is_lowest = true
        
        // Check surrounding bars
        for offset = 1 to local_high_or_low_search_window_size
            // Check left side
            left_index = target_bar_index - offset
            if map.contains(barMap, left_index)
                left_bar = map.get(barMap, left_index)
                if left_bar.bar_low <= target_bar.bar_low
                    is_lowest := false
                    break
            
            // Check right side
            right_index = target_bar_index + offset
            if map.contains(barMap, right_index)
                right_bar = map.get(barMap, right_index)
                if right_bar.bar_low <= target_bar.bar_low
                    is_lowest := false
                    break
        
        // is_lowest
        true

// === CORRECTED HIGH PIVOT CONFIRMATION FUNCTION ===
// Implements proper two-candle rule with gap validation for both green and red candidate scenarios
confirmHighPivot(int possible_high_pivot_bar_index) =>
    StructureLevel pivot_high_obj = na
    
    if not map.contains(barMap, possible_high_pivot_bar_index)
        pivot_high_obj
    else
        possible_high_pivot_bar_data = map.get(barMap, possible_high_pivot_bar_index)
        bool possible_high_pivot_bar_is_green = possible_high_pivot_bar_data.bar_close > possible_high_pivot_bar_data.bar_open
        search_end = possible_high_pivot_bar_index + pattern_search_loop_window_size
        
        // === SCENARIO 1: GREEN CANDIDATE CANDLE ===
        if possible_high_pivot_bar_is_green
            // Look for first red candle after the green candidate
            red_1_index = possible_high_pivot_bar_index + 1
            
            while red_1_index <= search_end and map.contains(barMap, red_1_index) and na(pivot_high_obj)
                red_1_bar_data = map.get(barMap, red_1_index)
                
                // CRITICAL: Check if any bar between candidate and current breaks the pivot high
                bool pattern_invalidated = false
                for gap_check = possible_high_pivot_bar_index to red_1_index
                    if map.contains(barMap, gap_check)
                        gap_bar_data = map.get(barMap, gap_check)
                        if gap_bar_data.bar_high > possible_high_pivot_bar_data.bar_high
                            pattern_invalidated := true
                            break
                
                if pattern_invalidated
                    break  // Pattern failed - exit function
                
                // Check if this is a red candle
                if red_1_bar_data.bar_close < red_1_bar_data.bar_open
                    // Found first red candle, now look for second red candle
                    red_2_index = red_1_index + 1
                    
                    while red_2_index <= search_end and map.contains(barMap, red_2_index) and na(pivot_high_obj)
                        red_2_bar_data = map.get(barMap, red_2_index)
                        
                        // Check if any bar between red_1 and red_2 breaks the pivot high
                        bool pattern_invalidated_2 = false
                        for gap_check = red_1_index + 1 to red_2_index
                            if map.contains(barMap, gap_check)
                                gap_bar_data = map.get(barMap, gap_check)
                                if gap_bar_data.bar_high > possible_high_pivot_bar_data.bar_high
                                    pattern_invalidated_2 := true
                                    break
                        
                        if pattern_invalidated_2
                            break  // Pattern failed for this red_2, try next
                        
                        // Check if this is a red candle that closes below red_1's low
                        if red_2_bar_data.bar_close < red_2_bar_data.bar_open and 
                           red_2_bar_data.bar_close < red_1_bar_data.bar_low
                            // PATTERN CONFIRMED FOR GREEN SCENARIO
                            pivot_high_obj := StructureLevel.new(
                                 barIndex = possible_high_pivot_bar_index,
                                 price_level = possible_high_pivot_bar_data.bar_high,
                                 is_confirmed = true,
                                 is_pivot_internal_to_bos = false,
                                 is_pivot_internal_to_choch = false,
                                 level_type = "pivot_high",
                                 confirmation_bar = red_2_index,
                                 is_resolved = false)
                            break
                        
                        red_2_index += 1
                    
                    // If we found a valid pattern, exit the outer loop
                    if not na(pivot_high_obj)
                        break
                
                red_1_index += 1
        
        // === SCENARIO 2: RED CANDIDATE CANDLE ===
        else
            // The candidate itself is the first red candle, look for second red candle
            red_1_bar_data = possible_high_pivot_bar_data  // Candidate is red_1
            red_2_index = possible_high_pivot_bar_index + 1
            
            while red_2_index <= search_end and map.contains(barMap, red_2_index) and na(pivot_high_obj)
                red_2_bar_data = map.get(barMap, red_2_index)
                
                // Check if any bar between candidate and current breaks the pivot high
                bool pattern_invalidated = false
                for gap_check = possible_high_pivot_bar_index + 1 to red_2_index
                    if map.contains(barMap, gap_check)
                        gap_bar_data = map.get(barMap, gap_check)
                        if gap_bar_data.bar_high > possible_high_pivot_bar_data.bar_high
                            pattern_invalidated := true
                            break
                
                if pattern_invalidated
                    break  // Pattern failed - exit function
                
                // Check if this is a red candle that closes below the candidate's low
                if red_2_bar_data.bar_close < red_2_bar_data.bar_open and 
                   red_2_bar_data.bar_close < red_1_bar_data.bar_low
                    // PATTERN CONFIRMED FOR RED SCENARIO
                    pivot_high_obj := StructureLevel.new(
                         barIndex = possible_high_pivot_bar_index,
                         price_level = possible_high_pivot_bar_data.bar_high,
                         is_confirmed = true,
                         is_pivot_internal_to_bos = false,
                         is_pivot_internal_to_choch = false,
                         level_type = "pivot_high",
                         confirmation_bar = red_2_index,
                         is_resolved = false)
                    break
                
                red_2_index += 1
        
        pivot_high_obj

// === MIRROR LOW PIVOT CONFIRMATION FUNCTION ===
// Implements proper two-candle rule with gap validation for both red and green candidate scenarios
confirmLowPivot(int possible_low_pivot_bar_index) =>
    StructureLevel pivot_low_obj = na
    
    if not map.contains(barMap, possible_low_pivot_bar_index)
        pivot_low_obj
    else
        possible_low_pivot_bar_data = map.get(barMap, possible_low_pivot_bar_index)
        bool possible_low_pivot_bar_is_red = possible_low_pivot_bar_data.bar_close < possible_low_pivot_bar_data.bar_open
        search_end = possible_low_pivot_bar_index + pattern_search_loop_window_size
        
        // === SCENARIO 1: RED CANDIDATE CANDLE ===
        if possible_low_pivot_bar_is_red
            // Look for first green candle after the red candidate
            green_1_index = possible_low_pivot_bar_index + 1
            
            while green_1_index <= search_end and map.contains(barMap, green_1_index) and na(pivot_low_obj)
                green_1_bar_data = map.get(barMap, green_1_index)
                
                // CRITICAL: Check if any bar between candidate and current breaks the pivot low
                bool pattern_invalidated = false
                for gap_check = possible_low_pivot_bar_index to green_1_index
                    if map.contains(barMap, gap_check)
                        gap_bar_data = map.get(barMap, gap_check)
                        if gap_bar_data.bar_low < possible_low_pivot_bar_data.bar_low
                            pattern_invalidated := true
                            break
                
                if pattern_invalidated
                    break  // Pattern failed - exit function
                
                // Check if this is a green candle
                if green_1_bar_data.bar_close > green_1_bar_data.bar_open
                    // Found first green candle, now look for second green candle
                    green_2_index = green_1_index + 1
                    
                    while green_2_index <= search_end and map.contains(barMap, green_2_index) and na(pivot_low_obj)
                        green_2_bar_data = map.get(barMap, green_2_index)
                        
                        // Check if any bar between green_1 and green_2 breaks the pivot low
                        bool pattern_invalidated_2 = false
                        for gap_check = green_1_index + 1 to green_2_index
                            if map.contains(barMap, gap_check)
                                gap_bar_data = map.get(barMap, gap_check)
                                if gap_bar_data.bar_low < possible_low_pivot_bar_data.bar_low
                                    pattern_invalidated_2 := true
                                    break
                        
                        if pattern_invalidated_2
                            break  // Pattern failed for this green_2, try next
                        
                        // Check if this is a green candle that closes above green_1's high
                        if green_2_bar_data.bar_close > green_2_bar_data.bar_open and 
                           green_2_bar_data.bar_close > green_1_bar_data.bar_high
                            // PATTERN CONFIRMED FOR RED SCENARIO
                            pivot_low_obj := StructureLevel.new(
                                 barIndex = possible_low_pivot_bar_index,
                                 price_level = possible_low_pivot_bar_data.bar_low,
                                 is_confirmed = true,
                                 is_pivot_internal_to_bos = false,
                                 is_pivot_internal_to_choch = false,
                                 level_type = "pivot_low",
                                 confirmation_bar = green_2_index,
                                 is_resolved = false)
                            break
                        
                        green_2_index += 1
                    
                    // If we found a valid pattern, exit the outer loop
                    if not na(pivot_low_obj)
                        break
                
                green_1_index += 1
        
        // === SCENARIO 2: GREEN CANDIDATE CANDLE ===
        else
            // The candidate itself is the first green candle, look for second green candle
            green_1_bar_data = possible_low_pivot_bar_data  // Candidate is green_1
            green_2_index = possible_low_pivot_bar_index + 1
            
            while green_2_index <= search_end and map.contains(barMap, green_2_index) and na(pivot_low_obj)
                green_2_bar_data = map.get(barMap, green_2_index)
                
                // Check if any bar between candidate and current breaks the pivot low
                bool pattern_invalidated = false
                for gap_check = possible_low_pivot_bar_index + 1 to green_2_index
                    if map.contains(barMap, gap_check)
                        gap_bar_data = map.get(barMap, gap_check)
                        if gap_bar_data.bar_low < possible_low_pivot_bar_data.bar_low
                            pattern_invalidated := true
                            break
                
                if pattern_invalidated
                    break  // Pattern failed - exit function
                
                // Check if this is a green candle that closes above the candidate's high
                if green_2_bar_data.bar_close > green_2_bar_data.bar_open and 
                   green_2_bar_data.bar_close > green_1_bar_data.bar_high
                    // PATTERN CONFIRMED FOR GREEN SCENARIO
                    pivot_low_obj := StructureLevel.new(
                         barIndex = possible_low_pivot_bar_index,
                         price_level = possible_low_pivot_bar_data.bar_low,
                         is_confirmed = true,
                         is_pivot_internal_to_bos = false,
                         is_pivot_internal_to_choch = false,
                         level_type = "pivot_low",
                         confirmation_bar = green_2_index,
                         is_resolved = false)
                    break
                
                green_2_index += 1
        
        pivot_low_obj

// Find lowest point within a bullish BOS range (between pivot high and BOS break)
findAndConfirmLowPivotInBullishBOS(StructureEvent bullish_BOS) =>
    StructureLevel pivot_low = na
    if not na(bullish_BOS)
        int search_start = bullish_BOS.reference_pivot_bar + 1
        int search_end = bullish_BOS.trigger_bar_index - 1
        
        if search_start <= search_end and map.contains(barMap, search_start)
            // Initialize with first bar's low in search range
            first_bar_data = map.get(barMap, search_start)
            int lowest_low_index = search_start
            float lowest_low_price = first_bar_data.bar_low
            
            int inside_bar_index = search_start + 1
            while inside_bar_index <= search_end and map.contains(barMap, inside_bar_index)
                inside_bar_data = map.get(barMap, inside_bar_index)
                if inside_bar_data.bar_low < lowest_low_price
                    lowest_low_index := inside_bar_index
                    lowest_low_price := inside_bar_data.bar_low
                inside_bar_index += 1

            // also store the internal low index in the BOS UDT
            bullish_BOS.internal_pivot_bar := lowest_low_index
            // Create the new pivot low
            pivot_low := StructureLevel.new(
                 barIndex = lowest_low_index,
                 price_level = lowest_low_price,
                 is_confirmed = true,
                 is_pivot_internal_to_bos = true,
                 is_pivot_internal_to_choch = false,
                 level_type = "pivot_low",
                 structure_label = na,
                 confirmation_bar = lowest_low_index,
                 is_resolved = false)
    pivot_low

// Find highest point within a bearish BOS range (between pivot low and BOS break)
findAndConfirmHighPivotInBearishBOS(StructureEvent bearish_BOS) =>
    StructureLevel pivot_high = na
    if not na(bearish_BOS)
        int search_start = bearish_BOS.reference_pivot_bar + 1
        int search_end = bearish_BOS.trigger_bar_index - 1
        
        if search_start <= search_end and map.contains(barMap, search_start)
            // Initialize with first bar's high in search range
            first_bar_data = map.get(barMap, search_start)
            int highest_high_index = search_start
            float highest_high_price = first_bar_data.bar_high
            
            int inside_bar_index = search_start + 1
            while inside_bar_index <= search_end and map.contains(barMap, inside_bar_index)
                inside_bar_data = map.get(barMap, inside_bar_index)
                if inside_bar_data.bar_high > highest_high_price
                    highest_high_index := inside_bar_index
                    highest_high_price := inside_bar_data.bar_high
                inside_bar_index += 1

            // also store the internal high index in the BOS UDT
            bearish_BOS.internal_pivot_bar := highest_high_index
            // Create the new pivot high
            pivot_high := StructureLevel.new(
                 barIndex = highest_high_index,
                 price_level = highest_high_price,
                 is_confirmed = true,
                 is_pivot_internal_to_bos = true,
                 is_pivot_internal_to_choch = false,
                 level_type = "pivot_high",
                 structure_label = na,
                 confirmation_bar = highest_high_index,
                 is_resolved = false)
    pivot_high

// === PIVOT RESOLUTION FUNCTIONS ===
// Resolve all previous unresolved pivots of same type before adding new one
addPivotHighWithResolution(StructureLevel new_pivot_high) =>
    // Mark all previous unresolved high pivots as resolved
    if array.size(pivot_highs) > 0
        for i = 0 to array.size(pivot_highs) - 1
            existing_pivot = array.get(pivot_highs, i)
            if not existing_pivot.is_resolved
                existing_pivot.is_resolved := true
                existing_pivot.crossing_struct_event_bar := new_pivot_high.barIndex
    
    // Add new pivot and create visuals
    array.push(pivot_highs, new_pivot_high)

addPivotLowWithResolution(StructureLevel new_pivot_low) =>
    // Mark all previous unresolved low pivots as resolved
    if array.size(pivot_lows) > 0
        for i = 0 to array.size(pivot_lows) - 1
            existing_pivot = array.get(pivot_lows, i)
            if not existing_pivot.is_resolved
                existing_pivot.is_resolved := true
                existing_pivot.crossing_struct_event_bar := new_pivot_low.barIndex
    
    // Add new pivot and create visuals
    array.push(pivot_lows, new_pivot_low)

// === VISUAL UTILITY FUNCTIONS ===
// Create visual elements for pivot points
createPivotVisuals(StructureLevel pivot) =>
    if not na(pivot)
        if pivot.level_type == "pivot_high"
            pivot.structure_label := label.new(
                 x = pivot.barIndex,
                 y = pivot.price_level,
                 text = "H",
                 style = label.style_label_down,
                 color = color.new(color.red, 100),
                 textcolor = color.red,
                 size = size.normal)
        else if pivot.level_type == "pivot_low"
            pivot.structure_label := label.new(
                 x = pivot.barIndex,
                 y = pivot.price_level,
                 text = "L",
                 style = label.style_label_up,
                 color = color.new(color.green, 100),
                 textcolor = color.green,
                 size = size.normal)
    pivot

// Create visual elements for BOS events
createBOSVisuals(StructureEvent bos_event) =>
    if not na(bos_event)
        // Create BOS line
        bos_event.event_line := line.new(
             x1 = bos_event.reference_pivot_bar,
             y1 = bos_event.broken_level,
             x2 = bos_event.trigger_bar_index,
             y2 = bos_event.broken_level,
             color = bos_event.direction == "bullish" ? color.green : color.red,
             width = 2,
             style = line.style_solid)
        
        // Create BOS label
        bos_event.event_label := label.new(
             x = int(math.round((bos_event.reference_pivot_bar + bos_event.trigger_bar_index) / 2)),
             y = bos_event.broken_level,
             text = bos_event.direction == "bullish" ? "BOS↑" : "BOS↓",
             style = bos_event.direction == "bullish" ? label.style_label_up : label.style_label_down,
             color = color.new(bos_event.direction == "bullish" ? color.green : color.red, 100),
             textcolor = bos_event.direction == "bullish" ? color.green : color.red,
             size = size.normal)
    bos_event

// Create visual elements for CHoCH events
createCHoCHVisuals(StructureEvent choch_event) =>
    if not na(choch_event)
        // Create CHoCH line
        choch_event.event_line := line.new(
             x1 = choch_event.reference_pivot_bar,
             y1 = choch_event.broken_level,
             x2 = choch_event.trigger_bar_index,
             y2 = choch_event.broken_level,
             color = choch_event.direction == "bullish" ? color.purple : color.orange,
             width = 2,
             style = line.style_solid)
        
        // Create CHoCH label
        choch_event.event_label := label.new(
             x = int(math.round((choch_event.reference_pivot_bar + choch_event.trigger_bar_index) / 2)),
             y = choch_event.broken_level,
             text = choch_event.direction == "bullish" ? "CHoCH↑" : "CHoCH↓",
             style = choch_event.direction == "bullish" ? label.style_label_up : label.style_label_down,
             color = color.new(choch_event.direction == "bullish" ? color.purple : color.orange, 100),
             textcolor = choch_event.direction == "bullish" ? color.purple : color.orange,
             size = size.normal)
    choch_event

// === CHoCH ZONE DETECTION FUNCTION ===
// Determines if a pivot point lies within a CHoCH transition zone
// Updates the is_pivot_internal_to_choch boolean in the StructureLevel object
checkIfPivotIsInternalToCHoCH(StructureLevel pivot) =>
    bool pivot_in_choch_detected = false
    if not na(pivot) and array.size(choch_events) > 0
        // Start from the most recent CHoCH events and work backwards for efficiency
        i = array.size(choch_events) - 1
        
        while i >= 0
            choch_event = array.get(choch_events, i)
            
            // Check if pivot lies within CHoCH zone (exclusive of endpoints)
            bool pivot_in_zone = pivot.barIndex > choch_event.reference_pivot_bar
                 and pivot.barIndex < choch_event.trigger_bar_index
            
            if pivot_in_zone
                // For PIVOT HIGH: Check if it lies within a BEARISH CHoCH zone
                if pivot.level_type == "pivot_high" and choch_event.direction == "bearish"
                    pivot.is_pivot_internal_to_choch := true
                    pivot_in_choch_detected := true
                    break  // Found matching CHoCH zone, no need to continue
                
                // For PIVOT LOW: Check if it lies within a BULLISH CHoCH zone  
                else if pivot.level_type == "pivot_low" and choch_event.direction == "bullish"
                    pivot.is_pivot_internal_to_choch := true
                    pivot_in_choch_detected := true
                    break  // Found matching CHoCH zone, no need to continue
            
            // If we've checked CHoCH events that occurred after this pivot, no point continuing
            // Since we're going backwards in time, if choch choch_event.trigger_bar_index < pivot.barIndex, 
            // all remaining CHoCH events will be even earlier
            if choch_event.trigger_bar_index < pivot.barIndex
                break
                
            i -= 1
    // Return the pivot pivot_in_choch_detected representing potentially updated is_pivot_internal_to_choch status
    pivot_in_choch_detected

// === REACTIVE BOS/CHOCH DETECTION FUNCTIONS ===
// Check if current bar IS a BOS trigger for given pivot
checkIfBarIsBOS(int target_bar_index, StructureLevel pivot, string check_direction) =>
    StructureEvent bos_event = na
    
    if not na(pivot) and pivot.is_confirmed and not pivot.is_resolved and 
       target_bar_index > pivot.confirmation_bar and map.contains(barMap, target_bar_index)
        
        current_bar_data = map.get(barMap, target_bar_index)
        
        if pivot.level_type == "pivot_high" and check_direction == "bullish"
            // Bullish BOS: Current bar closes above pivot high
            if current_bar_data.bar_close > pivot.price_level
                bos_event := StructureEvent.new(
                     trigger_bar_index = target_bar_index,
                     broken_level = pivot.price_level,
                     event_type = "BOS",
                     direction = "bullish",
                     reference_pivot_bar = pivot.barIndex)
                
                // Mark pivot as resolved
                pivot.is_resolved := true
                pivot.crossing_struct_event_bar := target_bar_index
        
        else if pivot.level_type == "pivot_low" and check_direction == "bearish"
            // Bearish BOS: Current bar closes below pivot low
            if current_bar_data.bar_close < pivot.price_level
                bos_event := StructureEvent.new(
                     trigger_bar_index = target_bar_index,
                     broken_level = pivot.price_level,
                     event_type = "BOS",
                     direction = "bearish",
                     reference_pivot_bar = pivot.barIndex)
                
                // Mark pivot as resolved
                pivot.is_resolved := true
                pivot.crossing_struct_event_bar := target_bar_index
    
    bos_event

checkIfBarIsCHoCH(int target_bar_index, StructureLevel pivot, string check_direction) =>
    StructureEvent choch_event = na
    
    if not na(pivot) and pivot.is_confirmed and not pivot.is_resolved and 
       target_bar_index > pivot.confirmation_bar and map.contains(barMap, target_bar_index)
        
        current_bar_data = map.get(barMap, target_bar_index)
        
        // CHoCH requires 2-candle confirmation pattern
        if map.contains(barMap, target_bar_index + 1)
            next_bar_data = map.get(barMap, target_bar_index + 1)
            
            // FIX 2: Add internal pivot check
            bool is_internal_pivot = (pivot.confirmation_bar == pivot.barIndex)
            if pivot.level_type == "pivot_low" and check_direction == "bearish"
                // Bearish CHoCH: Break below low with 2-candle confirmation
                if current_bar_data.bar_close < pivot.price_level and next_bar_data.bar_close < pivot.price_level
                    choch_event := StructureEvent.new(
                             trigger_bar_index = target_bar_index, // Use first confirmation candle
                             broken_level = pivot.price_level,
                             event_type = "CHoCH",
                             direction = "bearish",
                             reference_pivot_bar = pivot.barIndex)
                    
                    // Mark pivot as resolved
                    pivot.is_resolved := true
                    pivot.crossing_struct_event_bar := target_bar_index
            // FIX 1: Add trend check for pivot_high
            else if pivot.level_type == "pivot_high" and check_direction == "bullish"
                // Bullish CHoCH: Break above high with 2-candle confirmation
                if current_bar_data.bar_close > pivot.price_level and next_bar_data.bar_close > pivot.price_level
                    choch_event := StructureEvent.new(
                             trigger_bar_index = target_bar_index, // Use first confirmation candle
                             broken_level = pivot.price_level,
                             event_type = "CHoCH",
                             direction = "bullish",
                             reference_pivot_bar = pivot.barIndex)
                    
                    // Mark pivot as resolved
                    pivot.is_resolved := true
                    pivot.crossing_struct_event_bar := target_bar_index
    
    choch_event

// Check if pivot is valid for structure break based on current market context
isPivotValidForStructureBreak(StructureLevel pivot, string break_type, string check_direction, int target_bar_index) =>
    bool is_valid = false
    bool pivot_in_choch_detected = false

    if not na(pivot) and pivot.is_confirmed and not pivot.is_resolved
        
        last_bos = getLastBOS(target_bar_index)
        last_choch = getLastCHOCH(target_bar_index)
        
        // Get the most recent structure event
        StructureEvent last_structure_event = getLastMarketEventBOSorCHOCH(target_bar_index)
        // could use this bool directly but would rather use the bool defined in the actual UDT
        pivot_in_choch_detected := checkIfPivotIsInternalToCHoCH(pivot) 

        if break_type == "BOS"
            // BOS Rules:
            // 1. Can break any valid unresolved pivot (primary or internal)
            // 2. Must maintain trend direction consistency
            if not na(last_structure_event)
                // Check trend consistency
                if check_direction == "bullish" and last_structure_event.direction == "bullish" and pivot.level_type == "pivot_high"
                    is_valid := true  // Bullish trend breaking higher highs
                else if check_direction == "bearish" and last_structure_event.direction == "bearish" and pivot.level_type == "pivot_low"
                    is_valid := true  // Bearish trend breaking lower lows
            else
                // No prior structure - any pivot is valid for initial BOS
                is_valid := true
                
        else if break_type == "CHoCH"
            // CHoCH Rules:
            // 1. Must break opposite direction pivot
            // 2. Pivot must be formed AFTER the last same-direction structure event
            // 3. Internal pivots can create CHoCH if they're significant enough
            
            if not na(last_structure_event)
                if check_direction == "bearish" and last_structure_event.direction == "bullish" and pivot.level_type == "pivot_low"
                    // Bearish CHoCH: Breaking low in bullish trend
                    // Pivot must be formed after the last bullish structure event
                    if pivot.barIndex > last_structure_event.trigger_bar_index
                         or pivot.is_pivot_internal_to_bos or pivot.is_pivot_internal_to_choch
                        is_valid := true
                        
                else if check_direction == "bullish" and last_structure_event.direction == "bearish" and pivot.level_type == "pivot_high"
                    // Bullish CHoCH: Breaking high in bearish trend
                    // Pivot must be formed after the last bearish structure event  
                    if pivot.barIndex > last_structure_event.trigger_bar_index
                         or pivot.is_pivot_internal_to_bos or pivot.is_pivot_internal_to_choch
                        is_valid := true
    
    is_valid

// === BOS PIVOT RESOLUTION FUNCTION ===
// When a BOS occurs, resolve all opposite-direction unresolved pivots that occurred before the reference pivot
// This invalidates previous counter-trend pivots that are now irrelevant to the new trend structure
resolveOppositePivotsBeforeBOSZone(StructureEvent bos_event) =>
    if not na(bos_event) and bos_event.event_type == "BOS"
        
        if bos_event.direction == "bullish"
            // BULLISH BOS: Resolve all unresolved pivot lows behind the reference pivot high
            if array.size(pivot_lows) > 0
                i = array.size(pivot_lows) - 1
                while i >= 0
                    pivot_low = array.get(pivot_lows, i)
                    
                    // Check if this pivot low is unresolved and occurred before the reference pivot
                    if not pivot_low.is_resolved and pivot_low.barIndex < bos_event.reference_pivot_bar
                        // Mark as resolved by this BOS event
                        pivot_low.is_resolved := true
                    
                    i -= 1
        
        else if bos_event.direction == "bearish"
            // BEARISH BOS: Resolve all unresolved pivot highs behind the reference pivot low
            if array.size(pivot_highs) > 0
                i = array.size(pivot_highs) - 1
                while i >= 0
                    pivot_high = array.get(pivot_highs, i)
                    
                    // Check if this pivot high is unresolved and occurred before the reference pivot
                    if not pivot_high.is_resolved and pivot_high.barIndex < bos_event.reference_pivot_bar
                        // Mark as resolved by this BOS event
                        pivot_high.is_resolved := true
                    
                    i -= 1

// === TEMPORAL STATE PURGE FUNCTION ===
// Remove all structure objects that were detected after the target_bar_index
// This allows clean reprocessing of historical bars without future contamination
purgeStructuresAfterBarIndex(int target_bar_index) =>
    // === PURGE PIVOT HIGHS ===
    if array.size(pivot_highs) > 0
        // Work backwards to avoid index shifting issues during removal
        i = array.size(pivot_highs) - 1
        while i >= 0
            pivot = array.get(pivot_highs, i)
            if pivot.barIndex > target_bar_index
                // Delete visual elements if they exist
                if not na(pivot.structure_label)
                    label.delete(pivot.structure_label)
                // Remove from array
                array.remove(pivot_highs, i)
            i -= 1
    
    // === PURGE PIVOT LOWS ===
    if array.size(pivot_lows) > 0
        // Work backwards to avoid index shifting issues during removal
        i = array.size(pivot_lows) - 1
        while i >= 0
            pivot = array.get(pivot_lows, i)
            if pivot.barIndex > target_bar_index
                // Delete visual elements if they exist
                if not na(pivot.structure_label)
                    label.delete(pivot.structure_label)
                // Remove from array
                array.remove(pivot_lows, i)
            i -= 1
    
    // === PURGE BOS EVENTS ===
    if array.size(bos_events) > 0
        // Work backwards to avoid index shifting issues during removal
        i = array.size(bos_events) - 1
        while i >= 0
            bos_event = array.get(bos_events, i)
            if bos_event.trigger_bar_index > target_bar_index
                // Delete visual elements if they exist
                if not na(bos_event.event_line)
                    line.delete(bos_event.event_line)
                if not na(bos_event.event_label)
                    label.delete(bos_event.event_label)
                // Remove from array
                array.remove(bos_events, i)
            i -= 1
    
    // === PURGE CHOCH EVENTS ===
    if array.size(choch_events) > 0
        // Work backwards to avoid index shifting issues during removal
        i = array.size(choch_events) - 1
        while i >= 0
            choch_event = array.get(choch_events, i)
            if choch_event.trigger_bar_index > target_bar_index
                // Delete visual elements if they exist
                if not na(choch_event.event_line)
                    line.delete(choch_event.event_line)
                if not na(choch_event.event_label)
                    label.delete(choch_event.event_label)
                // Remove from array
                array.remove(choch_events, i)
            i -= 1
    
    // === RESET PIVOT RESOLUTION STATUS ===
    // For remaining pivots, check if their resolution was caused by purged events
    // and reset their resolution status if needed
    
    // Reset pivot highs that were resolved by purged events
    if array.size(pivot_highs) > 0
        for i = 0 to array.size(pivot_highs) - 1
            pivot = array.get(pivot_highs, i)
            if pivot.is_resolved and not na(pivot.crossing_struct_event_bar)
                if pivot.crossing_struct_event_bar > target_bar_index
                    // This pivot was resolved by a purged event - reset it
                    pivot.is_resolved := false
                    pivot.crossing_struct_event_bar := na
    
    // Reset pivot lows that were resolved by purged events  
    if array.size(pivot_lows) > 0
        for i = 0 to array.size(pivot_lows) - 1
            pivot = array.get(pivot_lows, i)
            if pivot.is_resolved and not na(pivot.crossing_struct_event_bar)
                if pivot.crossing_struct_event_bar > target_bar_index
                    // This pivot was resolved by a purged event - reset it
                    pivot.is_resolved := false
                    pivot.crossing_struct_event_bar := na
    
    // Return cleanup summary for debugging
    [array.size(pivot_highs), array.size(pivot_lows), array.size(bos_events), array.size(choch_events)]

// === FVG RELATED LOGIC HEAVY METHODS - CREATION / DELETION / MANAGEMENT / FVG OVERLAP DETECTION ===
// The logic for detecting and saving the FVG boxes inside the box array should come first
// every thing runs with accordance to candle[0] or current candle. the first condition is for checking if candle[2] and 
// candle[1] exist / check register or GPT for FVG definition.
detectAndStoreFVG(int target_bar_index) =>
    bool cand_detect_FVG = true
    BarData bar_2 = na
    BarData bar_0 = na

    if (not map.contains(barMap, target_bar_index)) or (not map.contains(barMap, target_bar_index - 2))
        cand_detect_FVG := false
    else
        bar_2 := map.get(barMap, target_bar_index - 2)
        bar_0 := map.get(barMap, target_bar_index)

    if (not na(bar_2)) and (not na(bar_0) and cand_detect_FVG)
        // For bullish FVG
        idx = target_bar_index
        if bar_0.bar_high > bar_2.bar_high and bar_0.bar_low - bar_2.bar_high > 0
            // FVG = low - high[2]
            bgColor = color.new(color.green, 70)
            fvgBox = createFVGBox(target_bar_index, left=idx + fvgbarsLeftOffset, right=na, top=bar_0.bar_low, bottom=bar_2.bar_high, bgCol=bgColor, fvgType=1)
            array.push(fvgBoxArray, fvgBox)

        // For bearish FVG
        if bar_0.bar_low < bar_2.bar_low and bar_2.bar_low - bar_0.bar_high > 0
            // FVG = low[2] - high
            bgColor = color.new(color.red, 70)
            fvgBox = createFVGBox(target_bar_index, left=idx + fvgbarsLeftOffset, right=na, top=bar_2.bar_low, bottom=bar_0.bar_high, bgCol=bgColor, fvgType=-1)
            array.push(fvgBoxArray, fvgBox)

deletionPolicyForFVGs(int target_bar_index) =>
    last_bos = getLastBOS(target_bar_index)
    string currentTrend = not na(last_bos) ? last_bos.direction : "neutral"

    last_choch = getLastCHOCH(target_bar_index)
    int fvgCutoffBar = not na(last_choch) ? last_choch.trigger_bar_index : target_bar_index - 200

    if array.size(fvgBoxArray) > 0
        i = array.size(fvgBoxArray) - 1
        while i >= 0
            delete_FVG = false
            fvgBoxRef = array.get(fvgBoxArray, i)
            shouldDecrementIndex = true
            
            if not na(fvgBoxRef) and not fvgBoxRef.isDeleted
                // Rule 1: Age-based - Keep if after CHoCH cutoff
                bool keepByAge = fvgBoxRef.createdAtBar >= fvgCutoffBar

                // FINAL DECISION: Keep only if BOTH conditions pass
                if keepByAge
                    delete_FVG := false  // Keep it
                else 
                    delete_FVG := true   // Delete it
           
                if delete_FVG
                    deletedIdx = findFvgBoxIndexByCreatedBar(fvgBoxArray, fvgBoxRef.createdAtBar)
                    if not na(deletedIdx)
                        box.delete(fvgBoxRef.boxRef)
                        array.remove(fvgBoxArray, deletedIdx)
                        shouldDecrementIndex := false

            if shouldDecrementIndex
                i -= 1
            else
                i := math.min(i, array.size(fvgBoxArray) - 1)

// Check if a price zone overlaps with any active FVG
doesZoneOverlapWithAnyFVG(float zoneTop, float zoneBottom, BarData current_bar) =>
    bool hasOverlap = false
    
    if array.size(fvgBoxArray) > 0
        for i = 0 to array.size(fvgBoxArray) - 1
            fvgBox = array.get(fvgBoxArray, i)
            
            if not na(fvgBox) and not fvgBox.isDeleted
                fvgTop = getFVGBoxTop(fvgBox)
                fvgBottom = getFVGBoxBottom(fvgBox)
                fvgLeft = getFVGBoxLeft(fvgBox)    
                // if fvgBox.createdAtBar < zone_start
                //     continue
                if fvgBox.createdAtBar > current_bar.barIndex
                    continue
                // Check for any overlap between zones
                // No overlap only if: zoneBottom > fvgTop OR zoneTop < fvgBottom
                if not (zoneBottom > fvgTop or zoneTop < fvgBottom)
                    hasOverlap := true
                    break
    
    hasOverlap

// === ENGULFING CANDLE DETECTION FUNCTIONS ===
// Check if current bar is a bullish engulfing candle
isBullishEngulfingCandle(int target_bar_index) =>
    bool is_bullish_ec = false
    
    if map.contains(barMap, target_bar_index) and map.contains(barMap, target_bar_index - 1)
        current_bar = map.get(barMap, target_bar_index)
        prev_bar = map.get(barMap, target_bar_index - 1)
        
        // Bullish engulfing: prev is bearish, current is bullish, engulfs prev body
        if prev_bar.bar_close < prev_bar.bar_open and 
           current_bar.bar_close > current_bar.bar_open and
           current_bar.bar_open <= prev_bar.bar_close and
           current_bar.bar_close >= prev_bar.bar_open
            is_bullish_ec := true
    
    is_bullish_ec

// Check if current bar is a bearish engulfing candle
isBearishEngulfingCandle(int target_bar_index) =>
    bool is_bearish_ec = false
    
    if map.contains(barMap, target_bar_index) and map.contains(barMap, target_bar_index - 1)
        current_bar = map.get(barMap, target_bar_index)
        prev_bar = map.get(barMap, target_bar_index - 1)
        
        // Bearish engulfing: prev is bullish, current is bearish, engulfs prev body
        if prev_bar.bar_close > prev_bar.bar_open and 
           current_bar.bar_close < current_bar.bar_open and
           current_bar.bar_open >= prev_bar.bar_close and
           current_bar.bar_close <= prev_bar.bar_open
            is_bearish_ec := true
    
    is_bearish_ec

// === BOS RETEST SIGNAL DETECTION WITH LABEL CREATION ===
// Check if current candle is retesting a bullish BOS with EC + FVG overlap
checkBullishBOSRetest(int target_bar_index) =>
    bool signal_detected = false
    last_choch = getLastCHOCH(target_bar_index)

    if not map.contains(barMap, target_bar_index)
        signal_detected
    else
        current_bar = map.get(barMap, target_bar_index)
        proximity_threshold = pipsToPrice(retestProximityThresholdPips)
        
        // Check all bullish BOS events (most recent first)
        if array.size(bos_events) > 0
            i = array.size(bos_events) - 1
            while i >= 0 and not signal_detected
                bos_event = array.get(bos_events, i)
                
                // Skip BOS events before last CHoCH
                if not na(last_choch) and bos_event.reference_pivot_bar < last_choch.trigger_bar_index
                    break
                
                // Only check bullish BOS that occurred before current bar
                if bos_event.direction == "bullish" and bos_event.trigger_bar_index < target_bar_index
                    
                    // Get the high pivot candle that created this BOS
                    if map.contains(barMap, bos_event.reference_pivot_bar)
                        pivot_bar = map.get(barMap, bos_event.reference_pivot_bar)
                        
                        // Define retest zone: between HIGH and CLOSE of high pivot candle
                        zone_top = pivot_bar.bar_high
                        zone_bottom = pivot_bar.bar_close
                        
                        // Check if current candle touches/crosses this zone
                        bool candle_in_zone = (current_bar.bar_low <= zone_top) and 
                                              (current_bar.bar_low >= zone_bottom)
                        
                        if candle_in_zone
                            // Check if this zone overlaps with any FVG
                            if doesZoneOverlapWithAnyFVG(zone_top, zone_bottom, current_bar)
                                // Check if current candle is bullish engulfing
                                if isBullishEngulfingCandle(target_bar_index)
                                    
                                    // === RSI FILTER (CONDITIONAL) ===
                                    bool rsi_filter_pass = true  // Default: pass if disabled
                                    
                                    if enableRSICheck and not na(bos_event.internal_pivot_bar)
                                        // Get internal pivot low
                                        if map.contains(barMap, bos_event.internal_pivot_bar)
                                            internal_pivot_low = map.get(barMap, bos_event.internal_pivot_bar)
                                            
                                            // Check if both RSI values exist
                                            if not na(internal_pivot_low.bar_rsi) and not na(current_bar.bar_rsi)
                                                // For bullish entry: Current RSI should be LOWER (more oversold)
                                                rsi_filter_pass := current_bar.bar_rsi < internal_pivot_low.bar_rsi
                                            else
                                                // If RSI not available, fail the filter
                                                rsi_filter_pass := false
                                    
                                    if rsi_filter_pass
                                        signal_detected := true
                                        
                                        // CREATE LABEL
                                        label.new(
                                             x = target_bar_index,
                                             y = current_bar.bar_low,
                                             text = "L",
                                             style = label.style_label_up,
                                             color = color.new(color.lime, 60),
                                             textcolor = color.white,
                                             size = size.normal,
                                             tooltip = "Bullish BOS Retest\nEC: ✓\nFVG: ✓\nRSI: " + 
                                                  (enableRSICheck ? "✓ (" + str.tostring(current_bar.bar_rsi, "#.#") + ")" : "OFF"))
               
                i -= 1
        
        signal_detected
        
// Check if current candle is retesting a bearish BOS with EC + FVG overlap
checkBearishBOSRetest(int target_bar_index) =>
    bool signal_detected = false
    last_choch = getLastCHOCH(target_bar_index)

    if not map.contains(barMap, target_bar_index)
        signal_detected
    else
        current_bar = map.get(barMap, target_bar_index)
        proximity_threshold = pipsToPrice(retestProximityThresholdPips)
        
        // Check all bearish BOS events (most recent first)
        if array.size(bos_events) > 0
            i = array.size(bos_events) - 1
            while i >= 0 and not signal_detected
                bos_event = array.get(bos_events, i)
                
                // Skip BOS events before last CHoCH
                if not na(last_choch) and bos_event.reference_pivot_bar < last_choch.trigger_bar_index
                    break
                
                // Only check bearish BOS that occurred before current bar
                if bos_event.direction == "bearish" and bos_event.trigger_bar_index < target_bar_index
                    
                    // Get the low pivot candle that created this BOS
                    if map.contains(barMap, bos_event.reference_pivot_bar)
                        pivot_bar = map.get(barMap, bos_event.reference_pivot_bar)
                        
                        // Define retest zone: between LOW and CLOSE of low pivot candle
                        zone_bottom = pivot_bar.bar_low
                        zone_top = pivot_bar.bar_close
                        
                        // Check if current candle touches/crosses this zone
                        bool candle_in_zone = (current_bar.bar_high >= zone_bottom) and 
                                              (current_bar.bar_high <= zone_top)
                        
                        if candle_in_zone
                            // Check if this zone overlaps with any FVG
                            if doesZoneOverlapWithAnyFVG(zone_top, zone_bottom, current_bar)
                                // Check if current candle is bearish engulfing
                                if isBearishEngulfingCandle(target_bar_index)
                                    
                                    // === RSI FILTER (CONDITIONAL) ===
                                    bool rsi_filter_pass = true  // Default: pass if disabled
                                    
                                    if enableRSICheck and not na(bos_event.internal_pivot_bar)
                                        // Get internal pivot high
                                        if map.contains(barMap, bos_event.internal_pivot_bar)
                                            internal_pivot_high = map.get(barMap, bos_event.internal_pivot_bar)
                                            
                                            // Check if both RSI values exist
                                            if not na(internal_pivot_high.bar_rsi) and not na(current_bar.bar_rsi)
                                                // For bearish entry: Current RSI should be HIGHER (more overbought)
                                                rsi_filter_pass := current_bar.bar_rsi > internal_pivot_high.bar_rsi
                                            else
                                                // If RSI not available, fail the filter
                                                rsi_filter_pass := false
                                    
                                    if rsi_filter_pass
                                        signal_detected := true
                                        
                                        // CREATE LABEL
                                        label.new(
                                             x = target_bar_index,
                                             y = current_bar.bar_high,
                                             text = "S",
                                             style = label.style_label_down,
                                             color = color.new(color.red, 60),
                                             textcolor = color.white,
                                             size = size.normal,
                                             tooltip = "Bearish BOS Retest\nEC: ✓\nFVG: ✓\nRSI: " + 
                                                  (enableRSICheck ? "✓ (" + str.tostring(current_bar.bar_rsi, "#.#") + ")" : "OFF"))
                
                i -= 1
        
        signal_detected

// === UPDATED SINGLE-BAR PROCESSING FUNCTION ===
processSingleBarForMarketStructure(int target_bar_index) =>
    bool pivot_high_detected = false
    bool pivot_low_detected = false
    bool bos_detected = false
    bool choch_detected = false

    // placeholders for things detected to later decide which ones to paint
    StructureLevel pivot_high_detected_OBJ = na
    StructureLevel pivot_low_detected_OBJ = na
    StructureEvent bos_detected_OBJ = na
    StructureEvent choch_detected_OBJ = na

    // === TEMPORAL STATE PURGE - PHASE 3 ONLY===
    // Remove all structures detected after target_bar_index for clean reprocessing
    if phase_one_complete and phase_two_complete
        [remaining_highs, remaining_lows, remaining_bos, remaining_choch] = purgeStructuresAfterBarIndex(target_bar_index)
    
    // Important reference positions.
    last_pivot_high = getLastPivotHigh(target_bar_index)
    last_unresolved_pivot_high = getLastUnresolvedPivotHigh(target_bar_index)
    last_resolved_pivot_high = getLastResolvedPivotHigh(target_bar_index)
    last_pivot_low = getLastPivotLow(target_bar_index)
    last_unresolved_pivot_low = getLastUnresolvedPivotLow(target_bar_index)
    last_resolved_pivot_low = getLastResolvedPivotLow(target_bar_index)
    last_bos = getLastBOS(target_bar_index)
    last_choch = getLastCHOCH(target_bar_index)
    last_market_level_high_or_low = getLastMarketLevelHighOrLow(target_bar_index)
    last_market_event_bos_or_choch = getLastMarketEventBOSorCHOCH(target_bar_index)
    
    // checks on bar's state
    is_bar_local_high = isLocalHigh(target_bar_index)
    is_bar_local_low = isLocalLow(target_bar_index)
    [is_bar_already_pivot_high, is_bar_already_pivot_low] = isBarAlreadyPivot(target_bar_index)

    // === PHASE 1: BOS/CHoCH DETECTION (Current bar as trigger) ===
    // BEARISH CHOCH
    // The bos and choch detection rules are outlined in the isPivotValidForStructureBreak() function 
    // if its clears those, we can proceed to test the price levels and other check related to the target_bar itself
    // in the checkIfBarIsBOS() and checkIfBarIsCHoCH() functions
    if isPivotValidForStructureBreak(last_unresolved_pivot_low, "CHoCH", "bearish", target_bar_index)
         and map.contains(barMap, target_bar_index)
        choch_detected_OBJ := checkIfBarIsCHoCH(target_bar_index, last_unresolved_pivot_low, "bearish")
        if not na(choch_detected_OBJ)
            choch_detected := true
    // BULLISH CHOCH
    // The choch detection rules are outlined in the isPivotValidForStructureBreak() function 
    if isPivotValidForStructureBreak(last_unresolved_pivot_high, "CHoCH", "bullish", target_bar_index)
         and map.contains(barMap, target_bar_index)
        choch_detected_OBJ := checkIfBarIsCHoCH(target_bar_index, last_unresolved_pivot_high, "bullish")
        if not na(choch_detected_OBJ)
            choch_detected := true
    // BULLISH BOS
    // In bos detection we also have to worry about the internal pivots detection unlike choch detection.
    if isPivotValidForStructureBreak(last_unresolved_pivot_high, "BOS", "bullish", target_bar_index)
         and map.contains(barMap, target_bar_index)
        bos_detected_OBJ := checkIfBarIsBOS(target_bar_index, last_unresolved_pivot_high, "bullish")
        if not na(bos_detected_OBJ)
            bos_detected := true
            // Create internal low within BOS range
            pivot_low_detected_OBJ := findAndConfirmLowPivotInBullishBOS(bos_detected_OBJ)
            if not na(pivot_low_detected_OBJ)
                pivot_low_detected := true
    // BEARISH BOS
    // In bos detection we also have to worry about the internal pivots detection unlike choch detection.
    if isPivotValidForStructureBreak(last_unresolved_pivot_low, "BOS", "bearish", target_bar_index)
         and map.contains(barMap, target_bar_index)
        bos_detected_OBJ := checkIfBarIsBOS(target_bar_index, last_unresolved_pivot_low, "bearish")
        if not na(bos_detected_OBJ)
            bos_detected := true
            // Create internal low within BOS range
            pivot_high_detected_OBJ := findAndConfirmHighPivotInBearishBOS(bos_detected_OBJ)
            if not na(pivot_high_detected_OBJ)
                pivot_high_detected := true

    // Important reference positions.
    last_pivot_high := getLastPivotHigh(target_bar_index)
    last_unresolved_pivot_high := getLastUnresolvedPivotHigh(target_bar_index)
    last_resolved_pivot_high := getLastResolvedPivotHigh(target_bar_index)
    last_pivot_low := getLastPivotLow(target_bar_index)
    last_unresolved_pivot_low := getLastUnresolvedPivotLow(target_bar_index)
    last_resolved_pivot_low := getLastResolvedPivotLow(target_bar_index)
    last_bos := getLastBOS(target_bar_index)
    last_choch := getLastCHOCH(target_bar_index)
    last_market_level_high_or_low := getLastMarketLevelHighOrLow(target_bar_index)
    last_market_event_bos_or_choch := getLastMarketEventBOSorCHOCH(target_bar_index)
    

    // === PHASE 2: PIVOT DETECTION ===
    // Only detect new pivots if no BOS/CHoCH detected
    // if not bos_detected and not choch_detected 
    // 1. Initial pivot high detection
    if na(last_pivot_high) and na(last_pivot_low) and na(last_bos) and na(last_choch) and
         is_bar_local_high and not is_bar_already_pivot_high
        pivot_high_detected_OBJ := confirmHighPivot(target_bar_index)
        if not na(pivot_high_detected_OBJ)
            pivot_high_detected := true

    // 2-1/2 Post-BOS/CHOCH pivot high detection  
    if na(last_unresolved_pivot_high) and not na(last_resolved_pivot_high) and not na(last_market_event_bos_or_choch) and
         last_market_event_bos_or_choch.trigger_bar_index <= target_bar_index and
        //  last_market_event_bos_or_choch.reference_pivot_bar == last_resolved_pivot_high.barIndex and
         is_bar_local_high and not is_bar_already_pivot_high
        pivot_high_detected_OBJ := confirmHighPivot(target_bar_index)
        if not na(pivot_high_detected_OBJ)
            pivot_high_detected := true

    // 2-2/2 Post-BOS/CHOCH pivot low detection  
    if na(last_unresolved_pivot_low) and not na(last_resolved_pivot_low) and not na(last_market_event_bos_or_choch) and
         last_market_event_bos_or_choch.trigger_bar_index <= target_bar_index and
        //  last_market_event_bos_or_choch.reference_pivot_bar == last_resolved_pivot_low.barIndex and
         is_bar_local_low and not is_bar_already_pivot_low
        pivot_low_detected_OBJ := confirmLowPivot(target_bar_index)
        if not na(pivot_low_detected_OBJ)
            pivot_low_detected := true

        // // 3. Fallback high pivot detection (anti-stale mechanism)
        // else if is_bar_local_high and not is_bar_already_pivot_high and 
        //      not na(last_unresolved_pivot_high) and target_bar_index > last_unresolved_pivot_high.confirmation_bar + 500
        //     pivot_high_detected_OBJ := confirmHighPivot(target_bar_index)
        //     if not na(pivot_high_detected_OBJ)
        //         pivot_high_detected := true

        // // 4. Fallback low pivot detection (anti-stale mechanism) 
        // else if is_bar_local_low and not is_bar_already_pivot_low and 
        //      not na(last_unresolved_pivot_low) and target_bar_index > last_unresolved_pivot_low.confirmation_bar + 500
        //     pivot_low_detected_OBJ := confirmLowPivot(target_bar_index)
        //     if not na(pivot_low_detected_OBJ)
        //         pivot_low_detected := true

    // === STORAGE AND VISUAL CREATION ===
    if pivot_high_detected and not na(pivot_high_detected_OBJ)
        addPivotHighWithResolution(pivot_high_detected_OBJ)
        // array.push(pivot_highs, pivot_high_detected_OBJ)
        pivot = createPivotVisuals(pivot_high_detected_OBJ)

    if pivot_low_detected and not na(pivot_low_detected_OBJ)
        addPivotLowWithResolution(pivot_low_detected_OBJ)
        // array.push(pivot_lows, pivot_low_detected_OBJ)
        pivot = createPivotVisuals(pivot_low_detected_OBJ)

    if bos_detected and not na(bos_detected_OBJ)
        array.push(bos_events, bos_detected_OBJ)
        resolveOppositePivotsBeforeBOSZone(bos_detected_OBJ)
        bos = createBOSVisuals(bos_detected_OBJ)

    if choch_detected and not na(choch_detected_OBJ)
        array.push(choch_events, choch_detected_OBJ)
        choch = createCHoCHVisuals(choch_detected_OBJ)

    [pivot_high_detected, pivot_low_detected, bos_detected, choch_detected]


processSingleBarForECFVGSignal(int target_bar_index) =>
    detectAndStoreFVG(target_bar_index)
    deletionPolicyForFVGs(target_bar_index)
    // Check for BOS retest entry signals
    bool bullish_entry_signal = checkBullishBOSRetest(target_bar_index)
    bool bearish_entry_signal = checkBearishBOSRetest(target_bar_index)
    // bool bearish_entry_signal = true
    [bullish_entry_signal, bearish_entry_signal]

// === PHASE 1: DATA COLLECTION ===
if not phase_one_complete
    addBarDataToMap(bar_index, open, high, low, close, volume)
    // running clearnup
    cleanupBarMapByRange()
    if barstate.islast
        phase_one_complete := true
        last_historical_bar_index := bar_index
        
        if show_debug_labels
            label.new(bar_index, high, "PHASE 1 COMPLETE\n" + str.tostring(map.size(barMap)) + " bars", 
                     style=label.style_label_down, color=color.blue, size=size.small)

// === PHASE 2: BULK HISTORICAL PROCESSING ===
if phase_one_complete and not phase_two_complete
    // running clearnup
    cleanupBarMapByRange()
    bar_keys = map.keys(barMap)
    array.sort(bar_keys, order.ascending)
    // Process each bar individually
    for i = 0 to array.size(bar_keys) - 1
        target_bar_index = array.get(bar_keys, i)
        [ph, pl, bos, choch] = processSingleBarForMarketStructure(target_bar_index)
        [bullish_sig, bearish_sig] = processSingleBarForECFVGSignal(target_bar_index)
    
    phase_two_complete := true
    
    if show_debug_labels
        label.new(bar_index, low, "PHASE 2 COMPLETE\nProcessed all historical bars", 
                 style=label.style_label_up, color=color.orange, size=size.small)

// === PHASE 3: REAL-TIME PROCESSING ===
if phase_one_complete and phase_two_complete and barstate.isconfirmed and (bar_index > last_historical_bar_index)
    // running clearnup
    cleanupBarMapByRange()
    addBarDataToMap(bar_index, open, high, low, close, volume)
    // Process new bar
    [ph, pl, bos, choch] = processSingleBarForMarketStructure(bar_index)
    [bullish_entry, bearish_entry] = processSingleBarForECFVGSignal(bar_index)
    
    // Also reprocess recent bars to catch newly formed patterns
    lookback_start = math.max(0, bar_index - 20)  // Process last 20 bars
    for check_index = lookback_start to bar_index - 1
        if map.contains(barMap, check_index)
            [ph_check, pl_check, bos_check, choch_check] = processSingleBarForMarketStructure(check_index)


// === DEBUG TABLE UPDATES ===
// Update debug table with current scores (only on last bar for performance)
if show_debug_labels and barstate.islast
    // Table headers
    table.cell(debugTable, 0, 0, "Left Trend Analysis", text_color=color.white, bgcolor=color.blue, text_size=size.normal)
    table.cell(debugTable, 1, 0, "Current Values", text_color=color.white, bgcolor=color.blue, text_size=size.normal)
    
    // Individual method scores
    table.cell(debugTable, 0, 1, "barMap size", text_color=color.white, text_size=size.small)
    table.cell(debugTable, 1, 1, str.tostring(map.size(barMap), "#.####"), text_color=color.white, text_size=size.small)
    
    table.cell(debugTable, 0, 2, "bar_index", text_color=color.white, text_size=size.small)
    table.cell(debugTable, 1, 2, str.tostring(bar_index), text_color=color.white, text_size=size.small)

    table.cell(debugTable, 0, 3, "Current RSI", text_color=color.white, text_size=size.small)
    current_rsi = getRSI(bar_index)
    rsi_color = not na(current_rsi) ? 
         (current_rsi > 70 ? color.red : current_rsi < 30 ? color.lime : color.white) : color.gray
    table.cell(debugTable, 1, 3, 
         not na(current_rsi) ? str.tostring(current_rsi, "#.##") : "N/A", 
         text_color=rsi_color, text_size=size.small)