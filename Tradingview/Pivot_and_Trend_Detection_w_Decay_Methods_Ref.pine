//@version=6
indicator(title = "Anti-Repainting Channel Pivot Detector", overlay = true, max_labels_count = 500)

// === USER INPUTS ===
g_Prescreening = "Local High/Low Prescreening"
enable_local_prescreening = input.bool(defval = true, title = "Enable Local High/Low Prescreening", 
     tooltip = "When enabled, bars must be local highs/lows before trend analysis is performed",
     group = g_Prescreening)
local_high_or_low_search_window_size = input.int(defval = 2, title = "Local Extreme Window Size", minval = 1, maxval = 10, step = 1,
     tooltip = "Number of bars on each side to check for local highs/lows",
     group = g_Prescreening)

g_Trend_Methods = "Trend Detection Method Controls"
trendDetectionPriceSelection = input.string(defval = "typical_price", title = "Price Source for Trend Detection", 
     options = ["typical_price", "weighted_price", "median_price", "true_price", "close"], 
     tooltip = "Price source for trend analysis",
     group = g_Trend_Methods)

lookback_limit = input.int(defval = 10, title = "Window Size (Lookback Distance)", minval = 2, maxval = 50, step = 1,
     tooltip = "Number of bars to analyze on each side - CRITICAL for anti-repainting buffer",
     group = g_Trend_Methods)

decay_factor = input.float(defval = 0.9, title = "Exponential Decay Factor", minval = 0.1, maxval = 0.99, step = 0.01,
     tooltip = "Controls how quickly bar influence decreases with distance",
     group = g_Trend_Methods)

sigma = input.float(defval = 2.0, title = "Gaussian Decay Spread (Sigma)", minval = 0.5, maxval = 5.0, step = 0.1,
     tooltip = "Controls Gaussian weight distribution spread",
     group = g_Trend_Methods)

enable_ema_method = input.bool(defval = true, title = "Enable EMA Slope Method", group = g_Trend_Methods)
enable_linear_method = input.bool(defval = true, title = "Enable Linear Decay Method", group = g_Trend_Methods)  
enable_exponential_method = input.bool(defval = true, title = "Enable Exponential Decay Method", group = g_Trend_Methods)
enable_gaussian_method = input.bool(defval = true, title = "Enable Gaussian Decay Method", group = g_Trend_Methods)

ema_weight = input.float(defval = 0.25, title = "EMA Method Weight", minval = 0.0, maxval = 1.0, step = 0.1, group = g_Trend_Methods)
linear_weight = input.float(defval = 0.25, title = "Linear Method Weight", minval = 0.0, maxval = 1.0, step = 0.1, group = g_Trend_Methods)
exponential_weight = input.float(defval = 0.25, title = "Exponential Method Weight", minval = 0.0, maxval = 1.0, step = 0.1, group = g_Trend_Methods)
gaussian_weight = input.float(defval = 0.25, title = "Gaussian Method Weight", minval = 0.0, maxval = 1.0, step = 0.1, group = g_Trend_Methods)

show_pivot_labels = input.bool(defval = true, title = "Show Pivot Labels", group = "Display")
show_trend_scores = input.bool(defval = false, title = "Show Detailed Trend Scores", group = "Display")
show_debug_labels = input.bool(defval = true, title = "Show Phase Debug Labels", group = "Display")
candle_data_storage_map_size = input.int(defval = 4000, title = "Data Storage Size", minval = 100, maxval = 5000, step = 100, group = "Display")

// === GLOBAL PHASE CONTROL VARS ===
var bool phase_one_complete = false
var bool phase_two_complete = false
var int last_historical_bar_index = na
var int phase_two_stop_index = na  // The bar where Phase 2 stopped (bar_index - lookback_limit)
var int processing_stop_index = na

// === DATA STRUCTURES ===
type BarData
    int   barIndex
    float bar_open
    float bar_high
    float bar_low
    float bar_close
    float bar_volume
    float price_source
    bool  is_local_high          // Prescreening: Is this a local high?
    bool  is_local_low           // Prescreening: Is this a local low?
    bool  is_processed_for_pivot
    bool  is_pivot_high
    bool  is_pivot_low
    float ema_slope_score_left
    float linear_decay_score_left
    float exponential_decay_score_left
    float gaussian_decay_score_left
    float ema_slope_score_right
    float linear_decay_score_right
    float exponential_decay_score_right
    float gaussian_decay_score_right
    int   trend_left    // -1/0/1
    int   trend_right   // -1/0/1

// Create BarData object
createBarData(int barIndex, float Open, float High, float Low, float Close, float Volume) =>
    calculated_price_source = switch trendDetectionPriceSelection
        "typical_price" => (High + Low + Close) / 3
        "weighted_price" => (Open + High + Low + Close) / 4
        "median_price" => (High + Low) / 2
        "true_price" => (High + Low + Close * 2) / 4
        "close" => Close
        => (High + Low + Close) / 3
    
    BarData.new(
         barIndex = barIndex,
         bar_open = Open,
         bar_high = High,
         bar_low = Low,
         bar_close = Close,
         bar_volume = Volume,
         price_source = calculated_price_source,
         is_local_high = false,
         is_local_low = false,
         is_processed_for_pivot = false,
         is_pivot_high = false,
         is_pivot_low = false,
         ema_slope_score_left = na,
         linear_decay_score_left = na,
         exponential_decay_score_left = na,
         gaussian_decay_score_left = na,
         ema_slope_score_right = na,
         linear_decay_score_right = na,
         exponential_decay_score_right = na,
         gaussian_decay_score_right = na,
         trend_left = 0,
         trend_right = 0)

// Update functions
updateLeftSideScores(bar_data_obj_ref, float ema_score, float linear_score, float exp_score, float gauss_score, int trend_result) =>
    bar_data_obj_ref.ema_slope_score_left := ema_score
    bar_data_obj_ref.linear_decay_score_left := linear_score
    bar_data_obj_ref.exponential_decay_score_left := exp_score
    bar_data_obj_ref.gaussian_decay_score_left := gauss_score
    bar_data_obj_ref.trend_left := trend_result

updateRightSideScores(bar_data_obj_ref, float ema_score, float linear_score, float exp_score, float gauss_score, int trend_result) =>
    bar_data_obj_ref.ema_slope_score_right := ema_score
    bar_data_obj_ref.linear_decay_score_right := linear_score
    bar_data_obj_ref.exponential_decay_score_right := exp_score
    bar_data_obj_ref.gaussian_decay_score_right := gauss_score
    bar_data_obj_ref.trend_right := trend_result

// === STORAGE MAP ===
var barMap = map.new<int, BarData>()

// Add bar data to map
addBarDataToMap(int barIndex, float Open, float High, float Low, float Close, float Volume) =>
    if not map.contains(barMap, barIndex)
        new_BarData_obj_ref = createBarData(barIndex, Open, High, Low, Close, Volume)
        map.put(barMap, barIndex, new_BarData_obj_ref)

// Cleanup old bars to prevent memory issues
cleanupBarMapByRange() =>
    if not na(bar_index)
        cutoff_bar_index = bar_index - candle_data_storage_map_size
        map_keys = map.keys(barMap)
        for i = 0 to array.size(map_keys) - 1
            key = array.get(map_keys, i)
            if key < cutoff_bar_index
                map.remove(barMap, key)
            else
                // Since maps maintain insertion order, we can break early
                // once we find a key that's >= cutoff (all subsequent keys will be newer)
                break
    true // just because a return is needed

// === LOCAL HIGH/LOW PRESCREENING FUNCTIONS ===

// Check if current bar is a local high
isLocalHigh(int target_bar_index, int window_size) =>
    if not map.contains(barMap, target_bar_index)
        false
    else
        target_bar = map.get(barMap, target_bar_index)
        bool is_highest = true
        
        // Check surrounding bars
        for offset = 1 to window_size
            // Check left side
            left_index = target_bar_index - offset
            if map.contains(barMap, left_index)
                left_bar = map.get(barMap, left_index)
                if left_bar.bar_high >= target_bar.bar_high
                    is_highest := false
                    break
            
            // Check right side
            right_index = target_bar_index + offset
            if map.contains(barMap, right_index)
                right_bar = map.get(barMap, right_index)
                if right_bar.bar_high >= target_bar.bar_high
                    is_highest := false
                    break
        
        is_highest

// Check if current bar is a local low
isLocalLow(int target_bar_index, int window_size) =>
    if not map.contains(barMap, target_bar_index)
        false
    else
        target_bar = map.get(barMap, target_bar_index)
        bool is_lowest = true
        
        // Check surrounding bars
        for offset = 1 to window_size
            // Check left side
            left_index = target_bar_index - offset
            if map.contains(barMap, left_index)
                left_bar = map.get(barMap, left_index)
                if left_bar.bar_low <= target_bar.bar_low
                    is_lowest := false
                    break
            
            // Check right side
            right_index = target_bar_index + offset
            if map.contains(barMap, right_index)
                right_bar = map.get(barMap, right_index)
                if right_bar.bar_low <= target_bar.bar_low
                    is_lowest := false
                    break
        
        is_lowest

// === TREND DETECTION METHODS ===

// Method 1: EMA-based slope analysis (LEFT SIDE)
getLeftTrendWithEMASlopeNormalized(int current_bar_index, int fast_length, int slow_length, int atr_length) =>
    is_processable = true
    
    if not map.contains(barMap, current_bar_index)
        is_processable := false
        
    required_lookback = math.max(fast_length, slow_length, atr_length)
    available_bars = 0
    
    for i = 1 to required_lookback
        past_bar_index = current_bar_index - i
        if map.contains(barMap, past_bar_index)
            available_bars += 1
        else
            break
    
    if available_bars < required_lookback
        is_processable := false

    if is_processable
        price_array = array.new<float>()
        j = available_bars
        while j >= 0
            bar_data = map.get(barMap, current_bar_index - j)
            array.push(price_array, bar_data.price_source)
            j -= 1

        alpha_fast = 2.0 / (fast_length + 1.0)
        ema_fast = array.get(price_array, 0)
        for i = 1 to array.size(price_array) - 1
            ema_fast := alpha_fast * array.get(price_array, i) + (1 - alpha_fast) * ema_fast

        alpha_slow = 2.0 / (slow_length + 1.0)
        ema_slow = array.get(price_array, 0)
        for i = 1 to array.size(price_array) - 1
            ema_slow := alpha_slow * array.get(price_array, i) + (1 - alpha_slow) * ema_slow

        tr_sum = 0.0
        tr_count = 0
        for i = 1 to math.min(atr_length, available_bars)
            current_bar = map.get(barMap, current_bar_index - i + 1)
            previous_bar = map.get(barMap, current_bar_index - i)
            tr = math.max(current_bar.bar_high - current_bar.bar_low,
                         math.abs(current_bar.bar_high - previous_bar.bar_close),
                         math.abs(current_bar.bar_low - previous_bar.bar_close))
            tr_sum += tr
            tr_count += 1

        atr = tr_count > 0 ? tr_sum / tr_count : 1.0
        slope_normalized = atr > 0 ? (ema_fast - ema_slow) / atr : 0.0
        slope_normalized
    else
        0.0

// Method 1: EMA-based slope analysis (RIGHT SIDE)
getRightTrendWithEMASlopeNormalized(int current_bar_index, int fast_length, int slow_length, int atr_length) =>
    is_processable = true
    
    if not map.contains(barMap, current_bar_index)
        is_processable := false
        
    required_lookback = math.max(fast_length, slow_length, atr_length)
    available_bars = 0
    
    for i = 1 to required_lookback
        future_bar_index = current_bar_index + i
        if map.contains(barMap, future_bar_index)
            available_bars += 1
        else
            break
    
    if available_bars < required_lookback
        is_processable := false

    if is_processable
        price_array = array.new<float>()
        for i = 0 to available_bars by 1
            bar_data = map.get(barMap, current_bar_index + i)
            array.push(price_array, bar_data.price_source)

        alpha_fast = 2.0 / (fast_length + 1.0)
        ema_fast = array.get(price_array, 0)
        for i = 1 to array.size(price_array) - 1
            ema_fast := alpha_fast * array.get(price_array, i) + (1 - alpha_fast) * ema_fast

        alpha_slow = 2.0 / (slow_length + 1.0)
        ema_slow = array.get(price_array, 0)
        for i = 1 to array.size(price_array) - 1
            ema_slow := alpha_slow * array.get(price_array, i) + (1 - alpha_slow) * ema_slow

        tr_sum = 0.0
        tr_count = 0
        for i = 1 to math.min(atr_length, available_bars)
            current_bar = map.get(barMap, current_bar_index + i)
            previous_bar = map.get(barMap, current_bar_index + i - 1)
            tr = math.max(current_bar.bar_high - current_bar.bar_low,
                         math.abs(current_bar.bar_high - previous_bar.bar_close),
                         math.abs(current_bar.bar_low - previous_bar.bar_close))
            tr_sum += tr
            tr_count += 1

        atr = tr_count > 0 ? tr_sum / tr_count : 1.0
        slope_normalized = atr > 0 ? (ema_fast - ema_slow) / atr : 0.0
        slope_normalized
    else
        0.0

// Method 2: Linear decay weighting (LEFT SIDE)
getLeftTrendWithLinearDecay(int current_bar_index, int lookback_limit) =>
    weighted_sum = 0.0
    total_weight = 0.0
    is_processable = true
    
    if not map.contains(barMap, current_bar_index)
        is_processable := false
        
    available_bars = 0
    for i = 1 to lookback_limit
        past_bar_index = current_bar_index - i
        if map.contains(barMap, past_bar_index)
            available_bars += 1
        else
            break
    
    if available_bars == 0
        is_processable := false
    
    if is_processable
        current_bar_data = map.get(barMap, current_bar_index)
        for i = 1 to available_bars
            past_bar_index = current_bar_index - i            
            past_bar_data = map.get(barMap, past_bar_index)
            weight = (available_bars - i + 1) / available_bars
            price_change = current_bar_data.price_source - past_bar_data.price_source
            weighted_sum += price_change * weight
            total_weight += weight
    
    if total_weight > 0
        weighted_sum / total_weight
    else
        0.0

// Method 2: Linear decay weighting (RIGHT SIDE)
getRightTrendWithLinearDecay(int current_bar_index, int lookback_limit) =>
    weighted_sum = 0.0
    total_weight = 0.0
    is_processable = true
    
    if not map.contains(barMap, current_bar_index)
        is_processable := false
        
    available_bars = 0
    for i = 1 to lookback_limit
        future_bar_index = current_bar_index + i
        if map.contains(barMap, future_bar_index)
            available_bars += 1
        else
            break
    
    if available_bars == 0
        is_processable := false
    
    if is_processable
        current_bar_data = map.get(barMap, current_bar_index)
        for i = 1 to available_bars
            future_bar_index = current_bar_index + i
            future_bar_data = map.get(barMap, future_bar_index)
            weight = (available_bars - i + 1) / available_bars
            price_change = future_bar_data.price_source - current_bar_data.price_source
            weighted_sum += price_change * weight
            total_weight += weight
    
    if total_weight > 0
        weighted_sum / total_weight
    else
        0.0

// Method 3: Exponential decay weighting (LEFT SIDE)
getLeftTrendWithExponentialDecay(int current_bar_index, int lookback_limit, float decay_factor) =>
    weighted_sum = 0.0
    total_weight = 0.0
    is_processable = true
    
    if not map.contains(barMap, current_bar_index)
        is_processable := false
        
    available_bars = 0
    for i = 1 to lookback_limit
        past_bar_index = current_bar_index - i
        if map.contains(barMap, past_bar_index)
            available_bars += 1
        else
            break
    
    if available_bars == 0
        is_processable := false

    if is_processable
        current_bar_data = map.get(barMap, current_bar_index)
        for i = 1 to available_bars
            past_bar_index = current_bar_index - i            
            past_bar_data = map.get(barMap, past_bar_index)
            weight = math.pow(decay_factor, i - 1)
            price_change = current_bar_data.price_source - past_bar_data.price_source
            weighted_sum += price_change * weight
            total_weight += weight
    
    if total_weight > 0
        weighted_sum / total_weight
    else
        0.0

// Method 3: Exponential decay weighting (RIGHT SIDE)
getRightTrendWithExponentialDecay(int current_bar_index, int lookback_limit, float decay_factor) =>
    weighted_sum = 0.0
    total_weight = 0.0
    is_processable = true
    
    if not map.contains(barMap, current_bar_index)
        is_processable := false
        
    available_bars = 0
    for i = 1 to lookback_limit
        future_bar_index = current_bar_index + i
        if map.contains(barMap, future_bar_index)
            available_bars += 1
        else
            break
    
    if available_bars == 0
        is_processable := false

    if is_processable
        current_bar_data = map.get(barMap, current_bar_index)
        for i = 1 to available_bars
            future_bar_index = current_bar_index + i
            future_bar_data = map.get(barMap, future_bar_index)
            weight = math.pow(decay_factor, i - 1)
            price_change = future_bar_data.price_source - current_bar_data.price_source
            weighted_sum += price_change * weight
            total_weight += weight
    
    if total_weight > 0
        weighted_sum / total_weight
    else
        0.0

// Method 4: Gaussian decay weighting (LEFT SIDE)
getLeftTrendWithGaussianDecay(int current_bar_index, int lookback_limit, float sigma) =>
    weighted_sum = 0.0
    total_weight = 0.0
    is_processable = true
    
    if not map.contains(barMap, current_bar_index)
        is_processable := false
        
    available_bars = 0
    for i = 1 to lookback_limit
        past_bar_index = current_bar_index - i
        if map.contains(barMap, past_bar_index)
            available_bars += 1
        else
            break
    
    if available_bars == 0
        is_processable := false
    
    if is_processable
        current_bar_data = map.get(barMap, current_bar_index)
        for i = 1 to available_bars
            past_bar_index = current_bar_index - i            
            past_bar_data = map.get(barMap, past_bar_index)
            weight = math.exp(-0.5 * math.pow(i / sigma, 2))
            price_change = current_bar_data.price_source - past_bar_data.price_source
            weighted_sum += price_change * weight
            total_weight += weight
    
    if total_weight > 0
        weighted_sum / total_weight
    else
        0.0

// Method 4: Gaussian decay weighting (RIGHT SIDE)
getRightTrendWithGaussianDecay(int current_bar_index, int lookback_limit, float sigma) =>
    weighted_sum = 0.0
    total_weight = 0.0
    is_processable = true
    
    if not map.contains(barMap, current_bar_index)
        is_processable := false
        
    available_bars = 0
    for i = 1 to lookback_limit
        future_bar_index = current_bar_index + i
        if map.contains(barMap, future_bar_index)
            available_bars += 1
        else
            break
    
    if available_bars == 0
        is_processable := false
    
    if is_processable
        current_bar_data = map.get(barMap, current_bar_index)
        for i = 1 to available_bars
            future_bar_index = current_bar_index + i
            future_bar_data = map.get(barMap, future_bar_index)
            weight = math.exp(-0.5 * math.pow(i / sigma, 2))
            price_change = future_bar_data.price_source - current_bar_data.price_source
            weighted_sum += price_change * weight
            total_weight += weight
    
    if total_weight > 0
        weighted_sum / total_weight
    else
        0.0

// === COMBINED TREND ANALYSIS ===
getLeftSideTrendAndStore(int current_bar_index, int lookback_limit) =>    
    bar_data_obj_ref = map.get(barMap, current_bar_index)
    
    float ema_slope_score = 0.0
    float linear_decay_score = 0.0
    float exponential_decay_score = 0.0
    float gaussian_decay_score = 0.0
    
    if enable_ema_method
        ema_slope_score := getLeftTrendWithEMASlopeNormalized(current_bar_index, 5, lookback_limit, lookback_limit) 
    
    if enable_linear_method
        linear_decay_score := getLeftTrendWithLinearDecay(current_bar_index, lookback_limit)
    
    if enable_exponential_method
        exponential_decay_score := getLeftTrendWithExponentialDecay(current_bar_index, lookback_limit, decay_factor)

    if enable_gaussian_method
        gaussian_decay_score := getLeftTrendWithGaussianDecay(current_bar_index, lookback_limit, sigma)

    total_weight = (enable_ema_method ? ema_weight : 0.0) + 
                  (enable_linear_method ? linear_weight : 0.0) + 
                  (enable_exponential_method ? exponential_weight : 0.0) + 
                  (enable_gaussian_method ? gaussian_weight : 0.0)
    
    final_score = 0.0
    if total_weight > 0
        final_score := (ema_slope_score * ema_weight + 
                       linear_decay_score * linear_weight + 
                       exponential_decay_score * exponential_weight + 
                       gaussian_decay_score * gaussian_weight) / total_weight
    
    trend_result = final_score > 0.1 ? 1 : final_score < -0.1 ? -1 : 0
    
    updateLeftSideScores(bar_data_obj_ref, ema_slope_score, linear_decay_score, 
                         exponential_decay_score, gaussian_decay_score, trend_result)
    
    [trend_result, ema_slope_score, linear_decay_score, exponential_decay_score, gaussian_decay_score, final_score]

getRightSideTrendAndStore(int current_bar_index, int lookback_limit) =>
    bar_data_obj_ref = map.get(barMap, current_bar_index)
    
    float ema_slope_score = 0.0
    float linear_decay_score = 0.0
    float exponential_decay_score = 0.0
    float gaussian_decay_score = 0.0
    
    if enable_ema_method
        ema_slope_score := getRightTrendWithEMASlopeNormalized(current_bar_index, 5, lookback_limit, lookback_limit) 
    
    if enable_linear_method
        linear_decay_score := getRightTrendWithLinearDecay(current_bar_index, lookback_limit)
    
    if enable_exponential_method
        exponential_decay_score := getRightTrendWithExponentialDecay(current_bar_index, lookback_limit, decay_factor)

    if enable_gaussian_method
        gaussian_decay_score := getRightTrendWithGaussianDecay(current_bar_index, lookback_limit, sigma)

    total_weight = (enable_ema_method ? ema_weight : 0.0) + 
                  (enable_linear_method ? linear_weight : 0.0) + 
                  (enable_exponential_method ? exponential_weight : 0.0) + 
                  (enable_gaussian_method ? gaussian_weight : 0.0)
    
    final_score = 0.0
    if total_weight > 0
        final_score := (ema_slope_score * ema_weight + 
                       linear_decay_score * linear_weight + 
                       exponential_decay_score * exponential_weight + 
                       gaussian_decay_score * gaussian_weight) / total_weight
    
    trend_result = final_score > 0.1 ? 1 : final_score < -0.1 ? -1 : 0
    
    updateRightSideScores(bar_data_obj_ref, ema_slope_score, linear_decay_score,
                         exponential_decay_score, gaussian_decay_score, trend_result)
    
    [trend_result, ema_slope_score, linear_decay_score, exponential_decay_score, gaussian_decay_score, final_score]

// === PIVOT DETECTION BASED ON TRENDS ===
analyzeBarForTrendBasedPivot(int target_bar_index, int lookback_limit) =>
    bool is_potential_high = false
    bool is_potential_low = false
    bool is_processed = false

    if map.contains(barMap, target_bar_index)
        bar_data_obj = map.get(barMap, target_bar_index)
        
        if not bar_data_obj.is_processed_for_pivot
            // === PRESCREENING: Check if bar is local high/low ===
            bool passes_prescreening = true
            
            if enable_local_prescreening
                // Check and store local high/low status
                bar_data_obj.is_local_high := isLocalHigh(target_bar_index, local_high_or_low_search_window_size)
                bar_data_obj.is_local_low := isLocalLow(target_bar_index, local_high_or_low_search_window_size)
                
                // Bar must be either a local high OR local low to pass prescreening
                passes_prescreening := bar_data_obj.is_local_high or bar_data_obj.is_local_low
            
            // === TREND ANALYSIS: Only if prescreening passed ===
            if passes_prescreening
                [left_trend, left_ema, left_linear, left_exp, left_gauss, left_final] = 
                     getLeftSideTrendAndStore(target_bar_index, lookback_limit)
                [right_trend, right_ema, right_linear, right_exp, right_gauss, right_final] = 
                     getRightSideTrendAndStore(target_bar_index, lookback_limit)
                
                // Pivot High: Rising into (left=1), falling from (right=-1)
                // AND must be local high if prescreening is enabled
                if left_trend == 1 and right_trend == -1
                    if enable_local_prescreening
                        is_potential_high := bar_data_obj.is_local_high
                    else
                        is_potential_high := true
                
                // Pivot Low: Falling into (left=-1), rising from (right=1)
                // AND must be local low if prescreening is enabled
                if left_trend == -1 and right_trend == 1
                    if enable_local_prescreening
                        is_potential_low := bar_data_obj.is_local_low
                    else
                        is_potential_low := true
                
                if show_pivot_labels
                    if is_potential_high
                        label_text = show_trend_scores ? 
                             "PIVOT HIGH\n" +
                             "L: ▲ R: ▼\n" +
                             "EMA: " + str.tostring(left_ema, "#.##") + "/" + str.tostring(right_ema, "#.##") + "\n" +
                             "LIN: " + str.tostring(left_linear, "#.##") + "/" + str.tostring(right_linear, "#.##") + "\n" +
                             "EXP: " + str.tostring(left_exp, "#.##") + "/" + str.tostring(right_exp, "#.##") + "\n" +
                             "GAU: " + str.tostring(left_gauss, "#.##") + "/" + str.tostring(right_gauss, "#.##") + "\n" +
                             "FIN: " + str.tostring(left_final, "#.##") + "/" + str.tostring(right_final, "#.##")
                             : "H"
                        
                        label.new(x = target_bar_index, y = bar_data_obj.bar_high, text = label_text,
                                 style = label.style_label_down, color = color.red, textcolor = color.white,
                                 size = show_trend_scores ? size.normal : size.small)
                    
                    if is_potential_low
                        label_text = show_trend_scores ?
                             "PIVOT LOW\n" +
                             "L: ▼ R: ▲\n" +
                             "EMA: " + str.tostring(left_ema, "#.##") + "/" + str.tostring(right_ema, "#.##") + "\n" +
                             "LIN: " + str.tostring(left_linear, "#.##") + "/" + str.tostring(right_linear, "#.##") + "\n" +
                             "EXP: " + str.tostring(left_exp, "#.##") + "/" + str.tostring(right_exp, "#.##") + "\n" +
                             "GAU: " + str.tostring(left_gauss, "#.##") + "/" + str.tostring(right_gauss, "#.##") + "\n" +
                             "FIN: " + str.tostring(left_final, "#.##") + "/" + str.tostring(right_final, "#.##")
                             : "L"
                        
                        label.new(x = target_bar_index, y = bar_data_obj.bar_low, text = label_text,
                                 style = label.style_label_up, color = color.green, textcolor = color.white,
                                 size = show_trend_scores ? size.normal : size.small)
            
            bar_data_obj.is_processed_for_pivot := true
            bar_data_obj.is_pivot_high := is_potential_high
            bar_data_obj.is_pivot_low := is_potential_low
            is_processed := true

    [is_potential_high, is_potential_low, is_processed]

// === PHASE 1: DATA COLLECTION ===
if not phase_one_complete
    addBarDataToMap(bar_index, open, high, low, close, volume)
    cleanupBarMapByRange()
    
    if barstate.islast
        phase_one_complete := true
        last_historical_bar_index := bar_index
        
        if show_debug_labels
            label.new(bar_index, high, "PHASE 1 COMPLETE\n" + str.tostring(map.size(barMap)) + " bars collected", 
                     style=label.style_label_down, color=color.blue, textcolor=color.white, size=size.small)

// === PHASE 2: HISTORICAL PROCESSING WITH BUFFER ===
if phase_one_complete and not phase_two_complete
    cleanupBarMapByRange()
    
    bar_keys = map.keys(barMap)
    array.sort(bar_keys, order.ascending)
    
    // CRITICAL: Stop processing at [last_bar - lookback_limit]
    // This leaves a buffer zone equal to our window size
    processing_stop_index := last_historical_bar_index - lookback_limit
    phase_two_stop_index := processing_stop_index
    
    // Process each bar up to the stop point
    for i = 0 to array.size(bar_keys) - 1
        target_bar_index = array.get(bar_keys, i)
        
        // GLOBAL IF: Stop before the buffer zone
        if target_bar_index <= processing_stop_index
            [ph, pl, processed] = analyzeBarForTrendBasedPivot(target_bar_index, lookback_limit)
    
    phase_two_complete := true
    
    if show_debug_labels
        label.new(processing_stop_index, low, 
                 "PHASE 2 COMPLETE\nStopped at buffer zone\nBuffer = " + str.tostring(lookback_limit) + " bars", 
                 style=label.style_label_up, color=color.orange, textcolor=color.white, size=size.small)

// === PHASE 3: REAL-TIME PROCESSING WITH ANTI-REPAINTING LOGIC ===
if phase_one_complete and phase_two_complete and barstate.isconfirmed
    cleanupBarMapByRange()
    
    // Add new bar to map
    if bar_index > last_historical_bar_index
        addBarDataToMap(bar_index, open, high, low, close, volume)
    
    // CRITICAL ANTI-REPAINTING LOGIC:
    // Only process bars that have TWICE the lookback_limit bars ahead of them
    // This ensures the right-side trend analysis has stable, unchanging context
    
    int bars_ahead_of_phase2_stop = bar_index - processing_stop_index
    
    // Wait until we have accumulated 2x lookback_limit bars beyond Phase 2 stop point
    if bars_ahead_of_phase2_stop >= (2 * lookback_limit)
        // Now we can safely process bars in the buffer zone
        // Process from Phase 2 stop point up to [current_bar - lookback_limit]
        int safe_processing_end = bar_index - lookback_limit
        
        bar_keys = map.keys(barMap)
        array.sort(bar_keys, order.ascending)
        
        for i = 0 to array.size(bar_keys) - 1
            target_bar_index = array.get(bar_keys, i)
            
            // Process bars between Phase 2 stop and the current buffer boundary
            if target_bar_index > processing_stop_index and target_bar_index <= safe_processing_end
                [ph, pl, processed] = analyzeBarForTrendBasedPivot(target_bar_index, lookback_limit)
        
        // Update the stop index to current safe processing end
        processing_stop_index := safe_processing_end

// === DEBUG TABLE ===
var table debugTable = table.new(position.top_right, 2, 11, 
     bgcolor = color.new(color.white, 30), 
     border_width = 1, border_color = color.gray)

if barstate.islast
    table.cell(debugTable, 0, 0, "Status", text_color=color.white, bgcolor=color.blue)
    table.cell(debugTable, 1, 0, "Value", text_color=color.white, bgcolor=color.blue)
    
    table.cell(debugTable, 0, 1, "Prescreening", text_color=color.black)
    table.cell(debugTable, 1, 1, enable_local_prescreening ? "✓ ON (Win=" + str.tostring(local_high_or_low_search_window_size) + ")" : "✗ OFF",
              text_color=enable_local_prescreening ? color.green : color.gray)
    
    table.cell(debugTable, 0, 2, "Phase 1", text_color=color.black)
    table.cell(debugTable, 1, 2, phase_one_complete ? "✓ Complete" : "In Progress", 
              text_color=phase_one_complete ? color.green : color.orange)
    
    table.cell(debugTable, 0, 3, "Phase 2", text_color=color.black)
    table.cell(debugTable, 1, 3, phase_two_complete ? "✓ Complete" : "In Progress",
              text_color=phase_two_complete ? color.green : color.orange)
    
    table.cell(debugTable, 0, 4, "Bars in Map", text_color=color.black)
    table.cell(debugTable, 1, 4, str.tostring(map.size(barMap)), text_color=color.black)
    
    table.cell(debugTable, 0, 5, "Current Bar", text_color=color.black)
    table.cell(debugTable, 1, 5, str.tostring(bar_index), text_color=color.black)
    
    table.cell(debugTable, 0, 6, "Phase 2 Stop", text_color=color.black)
    table.cell(debugTable, 1, 6, na(phase_two_stop_index) ? "N/A" : str.tostring(phase_two_stop_index), text_color=color.black)
    
    table.cell(debugTable, 0, 7, "Buffer Size", text_color=color.black)
    table.cell(debugTable, 1, 7, str.tostring(lookback_limit) + " bars", text_color=color.black)
    
    table.cell(debugTable, 0, 8, "Phase 3 Ready", text_color=color.black)
    int bars_ahead = phase_two_complete and not na(processing_stop_index) ? bar_index - processing_stop_index : 0
    bool phase3_ready = bars_ahead >= (2 * lookback_limit)
    table.cell(debugTable, 1, 8, phase3_ready ? "✓ YES" : "Waiting (" + str.tostring(bars_ahead) + "/" + str.tostring(2 * lookback_limit) + ")",
              text_color=phase3_ready ? color.green : color.orange)
    
    table.cell(debugTable, 0, 9, "Lookback", text_color=color.black)
    table.cell(debugTable, 1, 9, str.tostring(lookback_limit), text_color=color.black)
    
    table.cell(debugTable, 0, 10, "Price Source", text_color=color.black)
    table.cell(debugTable, 1, 10, trendDetectionPriceSelection, text_color=color.black)